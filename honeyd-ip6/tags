!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACK_DECREMENT	personality.h	/^enum ackchange { ACK_KEEP = 0, ACK_ZERO, ACK_DECREMENT };$/;"	e	enum:ackchange
ACK_KEEP	personality.h	/^enum ackchange { ACK_KEEP = 0, ACK_ZERO, ACK_DECREMENT };$/;"	e	enum:ackchange
ACK_ZERO	personality.h	/^enum ackchange { ACK_KEEP = 0, ACK_ZERO, ACK_DECREMENT };$/;"	e	enum:ackchange
ACTION	parse.c	/^     ACTION = 269,$/;"	e	enum:yytokentype	file:
ACTION	parse.c	276;"	d	file:
ACTION	parse.h	/^     ACTION = 269,$/;"	e	enum:yytokentype
ACTION	parse.h	140;"	d
ADD	parse.c	/^     ADD = 259,$/;"	e	enum:yytokentype	file:
ADD	parse.c	266;"	d	file:
ADD	parse.h	/^     ADD = 259,$/;"	e	enum:yytokentype
ADD	parse.h	130;"	d
ADDR_ADDR	tagging.h	/^	ADDR_TYPE, ADDR_BITS, ADDR_ADDR, ADDR_MAX_TAGS$/;"	e	enum:__anon8
ADDR_BITS	tagging.h	/^	ADDR_TYPE, ADDR_BITS, ADDR_ADDR, ADDR_MAX_TAGS$/;"	e	enum:__anon8
ADDR_MAX_TAGS	tagging.h	/^	ADDR_TYPE, ADDR_BITS, ADDR_ADDR, ADDR_MAX_TAGS$/;"	e	enum:__anon8
ADDR_TYPE	tagging.h	/^	ADDR_TYPE, ADDR_BITS, ADDR_ADDR, ADDR_MAX_TAGS$/;"	e	enum:__anon8
ALL_ROUTER_MULTICAST_ADDR	icmp6.c	62;"	d	file:
ANALYZE_REPORT_INTERVAL	analyze.h	35;"	d
ANNOTATE	parse.c	/^     ANNOTATE = 272,$/;"	e	enum:yytokentype	file:
ANNOTATE	parse.c	279;"	d	file:
ANNOTATE	parse.h	/^     ANNOTATE = 272,$/;"	e	enum:yytokentype
ANNOTATE	parse.h	143;"	d
ARP_EXTERNAL	arp.h	63;"	d
ARP_INTERNAL	arp.h	62;"	d
ARP_MAX_ACTIVE	arp.c	94;"	d	file:
BADARG	getopt_long.c	92;"	d	file:
BADCH	getopt_long.c	91;"	d	file:
BANDWIDTH	parse.c	/^     BANDWIDTH = 296,$/;"	e	enum:yytokentype	file:
BANDWIDTH	parse.c	303;"	d	file:
BANDWIDTH	parse.h	/^     BANDWIDTH = 296,$/;"	e	enum:yytokentype
BANDWIDTH	parse.h	167;"	d
BEGIN	lex.c	144;"	d	file:
BETWEEN	parse.c	/^     BETWEEN = 319,$/;"	e	enum:yytokentype	file:
BETWEEN	parse.c	326;"	d	file:
BETWEEN	parse.h	/^     BETWEEN = 319,$/;"	e	enum:yytokentype
BETWEEN	parse.h	190;"	d
BIND	parse.c	/^     BIND = 261,$/;"	e	enum:yytokentype	file:
BIND	parse.c	268;"	d	file:
BIND	parse.h	/^     BIND = 261,$/;"	e	enum:yytokentype
BIND	parse.h	132;"	d
BITS_IN_BYTE	network.c	59;"	d	file:
BLOCK	parse.c	/^     BLOCK = 264,$/;"	e	enum:yytokentype	file:
BLOCK	parse.c	271;"	d	file:
BLOCK	parse.h	/^     BLOCK = 264,$/;"	e	enum:yytokentype
BLOCK	parse.h	135;"	d
BLOOM	bloom.h	/^} BLOOM;$/;"	t	typeref:struct:__anon2
Buffer	honeydctl.c	/^char Buffer[LINELEN];$/;"	v
CBRACKET	parse.c	/^     CBRACKET = 306,$/;"	e	enum:yytokentype	file:
CBRACKET	parse.c	313;"	d	file:
CBRACKET	parse.h	/^     CBRACKET = 306,$/;"	e	enum:yytokentype
CBRACKET	parse.h	177;"	d
CHAR64LONG16	sha1.c	/^} CHAR64LONG16;$/;"	t	typeref:union:__anon1	file:
CHECK_FUNC	pyextend.c	920;"	d	file:
CLONE	parse.c	/^     CLONE = 262,$/;"	e	enum:yytokentype	file:
CLONE	parse.c	269;"	d	file:
CLONE	parse.h	/^     CLONE = 262,$/;"	e	enum:yytokentype
CLONE	parse.h	133;"	d
CMDSTRING	parse.c	/^     CMDSTRING = 335,$/;"	e	enum:yytokentype	file:
CMDSTRING	parse.c	342;"	d	file:
CMDSTRING	parse.h	/^     CMDSTRING = 335,$/;"	e	enum:yytokentype
CMDSTRING	parse.h	206;"	d
CMP	personality.h	62;"	d
COLON	parse.c	/^     COLON = 279,$/;"	e	enum:yytokentype	file:
COLON	parse.c	286;"	d	file:
COLON	parse.h	/^     COLON = 279,$/;"	e	enum:yytokentype
COLON	parse.h	150;"	d
CONNECTOR	pfctl_osfp.c	335;"	d	file:
CREATE	parse.c	/^     CREATE = 258,$/;"	e	enum:yytokentype	file:
CREATE	parse.c	265;"	d	file:
CREATE	parse.h	/^     CREATE = 258,$/;"	e	enum:yytokentype
CREATE	parse.h	129;"	d
CTLNAME	honeydctl.c	94;"	d	file:
D	debug.h	49;"	d
D	debug.h	71;"	d
DASH	parse.c	/^     DASH = 328,$/;"	e	enum:yytokentype	file:
DASH	parse.c	335;"	d	file:
DASH	parse.h	/^     DASH = 328,$/;"	e	enum:yytokentype
DASH	parse.h	199;"	d
DEBUG	honeyd_overload.c	104;"	d	file:
DEBUG	parse.c	/^     DEBUG = 327,$/;"	e	enum:yytokentype	file:
DEBUG	parse.c	334;"	d	file:
DEBUG	parse.h	/^     DEBUG = 327,$/;"	e	enum:yytokentype
DEBUG	parse.h	198;"	d
DEBUG	pfctl_osfp.c	58;"	d	file:
DECLARE	honeyd_overload.c	137;"	d	file:
DEFAULT	parse.c	/^     DEFAULT = 267,$/;"	e	enum:yytokentype	file:
DEFAULT	parse.c	274;"	d	file:
DEFAULT	parse.h	/^     DEFAULT = 267,$/;"	e	enum:yytokentype
DEFAULT	parse.h	138;"	d
DEFAULT_RANDOM_IPV6_PROBABILITY	honeyd.c	123;"	d	file:
DELAY_ETHERNET	honeyd.h	105;"	d
DELAY_EXTERNAL	honeyd.h	101;"	d
DELAY_FREEPKT	honeyd.h	102;"	d
DELAY_NEEDFREE	honeyd.h	100;"	d
DELAY_TUNNEL	honeyd.h	103;"	d
DELAY_UNREACH	honeyd.h	104;"	d
DELETE	parse.c	/^     DELETE = 320,$/;"	e	enum:yytokentype	file:
DELETE	parse.c	327;"	d	file:
DELETE	parse.h	/^     DELETE = 320,$/;"	e	enum:yytokentype
DELETE	parse.h	191;"	d
DFPRINTF	debug.h	33;"	d
DHCP	parse.c	/^     DHCP = 323,$/;"	e	enum:yytokentype	file:
DHCP	parse.c	330;"	d	file:
DHCP	parse.h	/^     DHCP = 323,$/;"	e	enum:yytokentype
DHCP	parse.h	194;"	d
DHREQ_STATE_BUSY	dhcpclient.h	75;"	d
DHREQ_STATE_WAITACK	dhcpclient.h	77;"	d
DHREQ_STATE_WAITANS	dhcpclient.h	76;"	d
DH_BOOTREPLY	dhcpclient.h	92;"	d
DH_BOOTREQUEST	dhcpclient.h	91;"	d
DH_DOMAINNAME	dhcpclient.h	108;"	d
DH_HOSTNAME	dhcpclient.h	107;"	d
DH_HTYPE_ETHERNET	dhcpclient.h	114;"	d
DH_MAGICCOOKIE	dhcpclient.h	94;"	d
DH_MSGTYPE	dhcpclient.h	110;"	d
DH_MSGTYPE_ACK	dhcpclient.h	100;"	d
DH_MSGTYPE_DECLINE	dhcpclient.h	99;"	d
DH_MSGTYPE_DISCOVER	dhcpclient.h	96;"	d
DH_MSGTYPE_NAK	dhcpclient.h	101;"	d
DH_MSGTYPE_OFFER	dhcpclient.h	97;"	d
DH_MSGTYPE_RELEASE	dhcpclient.h	102;"	d
DH_MSGTYPE_REQUEST	dhcpclient.h	98;"	d
DH_NS	dhcpclient.h	106;"	d
DH_PARAMREQ	dhcpclient.h	112;"	d
DH_REQIP	dhcpclient.h	109;"	d
DH_ROUTER	dhcpclient.h	105;"	d
DH_SERVIDENT	dhcpclient.h	111;"	d
DH_SUBNETMASK	dhcpclient.h	104;"	d
DIFF	ip6frag.c	59;"	d	file:
DIFF	ipfrag.c	73;"	d	file:
DIFF	util.c	384;"	d	file:
DLOPENLIBC	acconfig.h	59;"	d
DLOPENLIBC	config.h	61;"	d
DLOPENLIBC	config.h	71;"	d
DL_NEED_UNDERSCORE	acconfig.h	57;"	d
DOT	parse.c	/^     DOT = 263,$/;"	e	enum:yytokentype	file:
DOT	parse.c	270;"	d	file:
DOT	parse.h	/^     DOT = 263,$/;"	e	enum:yytokentype
DOT	parse.h	134;"	d
DPFPRINTF	pf_osfp.c	48;"	d	file:
DPFPRINTF	pf_osfp.c	50;"	d	file:
DPRINTF	honeyd_overload.c	106;"	d	file:
DPRINTF	honeyd_overload.c	108;"	d	file:
DROP	parse.c	/^     DROP = 276,$/;"	e	enum:yytokentype	file:
DROP	parse.c	283;"	d	file:
DROP	parse.h	/^     DROP = 276,$/;"	e	enum:yytokentype
DROP	parse.h	147;"	d
DROPRATE	parse.c	/^     DROPRATE = 282,$/;"	e	enum:yytokentype	file:
DROPRATE	parse.c	289;"	d	file:
DROPRATE	parse.h	/^     DROPRATE = 282,$/;"	e	enum:yytokentype
DROPRATE	parse.h	153;"	d
DYNAMIC	parse.c	/^     DYNAMIC = 311,$/;"	e	enum:yytokentype	file:
DYNAMIC	parse.c	318;"	d	file:
DYNAMIC	parse.h	/^     DYNAMIC = 311,$/;"	e	enum:yytokentype
DYNAMIC	parse.h	182;"	d
D_ASSERT	debug.h	59;"	d
D_ASSERT	debug.h	72;"	d
D_ASSERT_PTR	debug.h	68;"	d
D_ASSERT_PTR	debug.h	73;"	d
ECHO	lex.c	889;"	d	file:
EMSG	getopt_long.c	95;"	d	file:
ENTRY	parse.c	/^     ENTRY = 288,$/;"	e	enum:yytokentype	file:
ENTRY	parse.c	295;"	d	file:
ENTRY	parse.h	/^     ENTRY = 288,$/;"	e	enum:yytokentype
ENTRY	parse.h	159;"	d
EOB_ACT_CONTINUE_SCAN	lex.c	187;"	d	file:
EOB_ACT_END_OF_FILE	lex.c	188;"	d	file:
EOB_ACT_LAST_MATCH	lex.c	189;"	d	file:
EQUAL	parse.c	/^     EQUAL = 315,$/;"	e	enum:yytokentype	file:
EQUAL	parse.c	322;"	d	file:
EQUAL	parse.h	/^     EQUAL = 315,$/;"	e	enum:yytokentype
EQUAL	parse.h	186;"	d
ETHERNET	parse.c	/^     ETHERNET = 322,$/;"	e	enum:yytokentype	file:
ETHERNET	parse.c	329;"	d	file:
ETHERNET	parse.h	/^     ETHERNET = 322,$/;"	e	enum:yytokentype
ETHERNET	parse.h	193;"	d
EXIT_SUCCESS	parse.c	499;"	d	file:
EXIT_SUCCESS	parse.c	527;"	d	file:
EXPAND	pfctl_osfp.c	422;"	d	file:
FAKE_PF_KERNEL	pfctl_osfp.c	38;"	d	file:
FD_BOUND	honeyd_overload.c	181;"	d	file:
FD_CONNECTED	honeyd_overload.c	182;"	d	file:
FD_CONNECTING	honeyd_overload.c	183;"	d	file:
FD_GETSOCKNAME	honeyd_overload.c	186;"	d	file:
FD_INTERNAL_USE	honeyd_overload.c	185;"	d	file:
FD_UNBOUND	honeyd_overload.c	180;"	d	file:
FILENAMESTRING	parse.c	/^     FILENAMESTRING = 338,$/;"	e	enum:yytokentype	file:
FILENAMESTRING	parse.c	345;"	d	file:
FILENAMESTRING	parse.h	/^     FILENAMESTRING = 338,$/;"	e	enum:yytokentype
FILENAMESTRING	parse.h	209;"	d
FINGERPRINT	personality.h	61;"	d
FINSCAN	parse.c	/^     FINSCAN = 274,$/;"	e	enum:yytokentype	file:
FINSCAN	parse.c	281;"	d	file:
FINSCAN	parse.h	/^     FINSCAN = 274,$/;"	e	enum:yytokentype
FINSCAN	parse.h	145;"	d
FLAG_ALLARGS	getopt_long.c	87;"	d	file:
FLAG_LONGONLY	getopt_long.c	88;"	d	file:
FLAG_PERMUTE	getopt_long.c	86;"	d	file:
FLEXINT_H	lex.c	48;"	d	file:
FLEX_BETA	lex.c	32;"	d	file:
FLEX_SCANNER	lex.c	27;"	d	file:
FLOAT	parse.c	/^     FLOAT = 343$/;"	e	enum:yytokentype	file:
FLOAT	parse.c	350;"	d	file:
FLOAT	parse.h	/^     FLOAT = 343$/;"	e	enum:yytokentype
FLOAT	parse.h	214;"	d
FRAGMENT	parse.c	/^     FRAGMENT = 275,$/;"	e	enum:yytokentype	file:
FRAGMENT	parse.c	282;"	d	file:
FRAGMENT	parse.h	/^     FRAGMENT = 275,$/;"	e	enum:yytokentype
FRAGMENT	parse.h	146;"	d
FRAG_DROP	personality.h	/^enum fragpolicy {FRAG_OLD = 0, FRAG_DROP, FRAG_NEW};$/;"	e	enum:fragpolicy
FRAG_NEW	personality.h	/^enum fragpolicy {FRAG_OLD = 0, FRAG_DROP, FRAG_NEW};$/;"	e	enum:fragpolicy
FRAG_OLD	personality.h	/^enum fragpolicy {FRAG_OLD = 0, FRAG_DROP, FRAG_NEW};$/;"	e	enum:fragpolicy
FROM	parse.c	/^     FROM = 303,$/;"	e	enum:yytokentype	file:
FROM	parse.c	310;"	d	file:
FROM	parse.h	/^     FROM = 303,$/;"	e	enum:yytokentype
FROM	parse.h	174;"	d
FW_DROP	honeyd.h	/^	FW_DROP = 0, FW_INTERNAL, FW_EXTERNAL$/;"	e	enum:forward
FW_EXTERNAL	honeyd.h	/^	FW_DROP = 0, FW_INTERNAL, FW_EXTERNAL$/;"	e	enum:forward
FW_INTERNAL	honeyd.h	/^	FW_DROP = 0, FW_INTERNAL, FW_EXTERNAL$/;"	e	enum:forward
F_XXX_GETSOCK	honeyd_overload.h	46;"	d
GETADDR	honeyd_overload.c	175;"	d	file:
GETBIT	bloom.c	9;"	d	file:
GET_INT	pfctl_osfp.c	150;"	d	file:
GET_STR	pfctl_osfp.c	152;"	d	file:
GID	parse.c	/^     GID = 286,$/;"	e	enum:yytokentype	file:
GID	parse.c	293;"	d	file:
GID	parse.h	/^     GID = 286,$/;"	e	enum:yytokentype
GID	parse.h	157;"	d
GRE_CHECKSUM	gre.h	43;"	d
GRE_IP4PROTO	gre.h	45;"	d
GRE_NOCKSUM_DATA	gre.h	47;"	d
GRE_VERSION	gre.h	44;"	d
HAVE_ACCRIGHTS_IN_MSGHDR	acconfig.h	5;"	d
HAVE_ASPRINTF	config.h	80;"	d
HAVE_ASSERT_H	config.h	83;"	d
HAVE_BROKEN_DNET	acconfig.h	11;"	d
HAVE_CONTROL_IN_MSGHDR	acconfig.h	8;"	d
HAVE_CONTROL_IN_MSGHDR	config.h	10;"	d
HAVE_CONTROL_IN_MSGHDR	config.h	86;"	d
HAVE_DAEMON	config.h	89;"	d
HAVE_DLFCN_H	config.h	92;"	d
HAVE_DUMBNET	config.h	98;"	d
HAVE_DUP2	config.h	101;"	d
HAVE_ERR	config.h	104;"	d
HAVE_ERRNO_H	config.h	107;"	d
HAVE_FCNTL_H	config.h	110;"	d
HAVE_FREEADDRINFO	config.h	116;"	d
HAVE_GETADDRINFO	config.h	119;"	d
HAVE_GETNAMEINFO	config.h	122;"	d
HAVE_GETOPT_LONG	config.h	125;"	d
HAVE_GETTIMEOFDAY	config.h	128;"	d
HAVE_INTTYPES_H	config.h	131;"	d
HAVE_ISBLANK	acconfig.h	52;"	d
HAVE_ISBLANK	config.h	134;"	d
HAVE_ISBLANK	config.h	54;"	d
HAVE_LIBEVENT	config.h	143;"	d
HAVE_LIBREADLINE	config.h	146;"	d
HAVE_LIBZ	config.h	149;"	d
HAVE_MEMMOVE	config.h	152;"	d
HAVE_MEMORY_H	config.h	155;"	d
HAVE_MEMSET	config.h	158;"	d
HAVE_PATHS_H	config.h	164;"	d
HAVE_PCAP_GET_SELECTABLE_FD	config.h	167;"	d
HAVE_RECVMSG	config.h	176;"	d
HAVE_SENDMSG	config.h	179;"	d
HAVE_SETGROUPS	config.h	182;"	d
HAVE_SETREGID	config.h	185;"	d
HAVE_STDARG_H	config.h	197;"	d
HAVE_STDINT_H	config.h	200;"	d
HAVE_STDLIB_H	config.h	203;"	d
HAVE_STRCASECMP	config.h	206;"	d
HAVE_STRCHR	config.h	209;"	d
HAVE_STRDUP	config.h	212;"	d
HAVE_STRINGS_H	config.h	215;"	d
HAVE_STRING_H	config.h	218;"	d
HAVE_STRNCASECMP	config.h	227;"	d
HAVE_STRSEP	config.h	230;"	d
HAVE_STRSPN	config.h	233;"	d
HAVE_STRTOUL	config.h	236;"	d
HAVE_STRUCT_SOCKADDR_STORAGE	acconfig.h	2;"	d
HAVE_STRUCT_SOCKADDR_STORAGE	config.h	239;"	d
HAVE_STRUCT_SOCKADDR_STORAGE	config.h	4;"	d
HAVE_SYSLOG_H	config.h	245;"	d
HAVE_SYS_FILE_H	config.h	248;"	d
HAVE_SYS_IOCTL_H	config.h	254;"	d
HAVE_SYS_PARAM_H	config.h	257;"	d
HAVE_SYS_SOCKET_H	config.h	260;"	d
HAVE_SYS_STAT_H	config.h	263;"	d
HAVE_SYS_TIME_H	config.h	266;"	d
HAVE_SYS_TYPES_H	config.h	269;"	d
HAVE_SYS_WAIT_H	config.h	272;"	d
HAVE_TIMERADD	acconfig.h	29;"	d
HAVE_TIMERADD	config.h	275;"	d
HAVE_TIMERADD	config.h	31;"	d
HAVE_TIME_H	config.h	278;"	d
HAVE_UNISTD_H	config.h	281;"	d
HAVE_VPRINTF	config.h	284;"	d
HD_CONFIG_FLT	plugins_config.h	/^	HD_CONFIG_INT, HD_CONFIG_FLT, HD_CONFIG_STR$/;"	e	enum:honeyd_plugin_cfgtype
HD_CONFIG_INT	plugins_config.h	/^	HD_CONFIG_INT, HD_CONFIG_FLT, HD_CONFIG_STR$/;"	e	enum:honeyd_plugin_cfgtype
HD_CONFIG_STR	plugins_config.h	/^	HD_CONFIG_INT, HD_CONFIG_FLT, HD_CONFIG_STR$/;"	e	enum:honeyd_plugin_cfgtype
HD_DIR_MAX	hooks.h	/^	HD_DIR_MAX$/;"	e	enum:__anon3
HD_Direction	hooks.h	/^} HD_Direction;$/;"	t	typeref:enum:__anon3
HD_HOOKS_ICMP	hooks.c	82;"	d	file:
HD_HOOKS_LAST	hooks.c	84;"	d	file:
HD_HOOKS_OTHER	hooks.c	83;"	d	file:
HD_HOOKS_TCP	hooks.c	80;"	d	file:
HD_HOOKS_UDP	hooks.c	81;"	d	file:
HD_INCOMING	hooks.h	/^	HD_INCOMING, HD_OUTGOING, HD_INCOMING_STREAM, \/* just the payload that is actually new *\/$/;"	e	enum:__anon3
HD_INCOMING_STREAM	hooks.h	/^	HD_INCOMING, HD_OUTGOING, HD_INCOMING_STREAM, \/* just the payload that is actually new *\/$/;"	e	enum:__anon3
HD_OUTGOING	hooks.h	/^	HD_INCOMING, HD_OUTGOING, HD_INCOMING_STREAM, \/* just the payload that is actually new *\/$/;"	e	enum:__anon3
HD_PacketCallback	hooks.h	/^typedef void (*HD_PacketCallback)(struct tuple *conhdr, u_char *packet_data,$/;"	t
HMAC_BLOCK_SIZE	stats.h	41;"	d
HONEYD_ADDR_MASK	honeyd.h	55;"	d
HONEYD_CLOSE_WAIT	honeyd.h	46;"	d
HONEYD_DFL_TTL	honeyd.h	49;"	d
HONEYD_IDLE_TIMEOUT	honeyd.h	48;"	d
HONEYD_MAX_CONNECTS	honeyd.h	44;"	d
HONEYD_MAX_INTERFACES	honeyd.h	42;"	d
HONEYD_MAX_SOFTERRS	honeyd.h	51;"	d
HONEYD_MTU	honeyd.h	41;"	d
HONEYD_POLL_INTERVAL	honeyd.h	53;"	d
HONEYD_SOCK	honeydctl.c	95;"	d	file:
HONEYD_SYN_WAIT	honeyd.h	47;"	d
HONEYD_UDP_WAIT	honeyd.h	50;"	d
HSNIFF_CON_EXPIRE	hsniff.h	37;"	d
HSNIFF_MAX_INTERFACES	hsniff.h	36;"	d
HSNIFF_PIDFILE	hsniff.h	35;"	d
HoneydMethods	pyextend.c	/^static PyMethodDef HoneydMethods[] = {$/;"	v	file:
ID_CONSTANT	personality.h	/^               ID_CONSTANT, ID_RPI};$/;"	e	enum:ipidtype
ID_MAX	personality.h	63;"	d
ID_RANDOM	personality.h	/^enum ipidtype {ID_SEQUENTIAL, ID_RANDOM, ID_SEQUENTIAL_BROKEN, ID_ZERO,$/;"	e	enum:ipidtype
ID_RPI	personality.h	/^               ID_CONSTANT, ID_RPI};$/;"	e	enum:ipidtype
ID_SEQUENTIAL	personality.h	/^enum ipidtype {ID_SEQUENTIAL, ID_RANDOM, ID_SEQUENTIAL_BROKEN, ID_ZERO,$/;"	e	enum:ipidtype
ID_SEQUENTIAL_BROKEN	personality.h	/^enum ipidtype {ID_SEQUENTIAL, ID_RANDOM, ID_SEQUENTIAL_BROKEN, ID_ZERO,$/;"	e	enum:ipidtype
ID_ZERO	personality.h	/^enum ipidtype {ID_SEQUENTIAL, ID_RANDOM, ID_SEQUENTIAL_BROKEN, ID_ZERO,$/;"	e	enum:ipidtype
IF	parse.c	/^     IF = 313,$/;"	e	enum:yytokentype	file:
IF	parse.c	320;"	d	file:
IF	parse.h	/^     IF = 313,$/;"	e	enum:yytokentype
IF	parse.h	184;"	d
IN	parse.c	/^     IN = 283,$/;"	e	enum:yytokentype	file:
IN	parse.c	290;"	d	file:
IN	parse.h	/^     IN = 283,$/;"	e	enum:yytokentype
IN	parse.h	154;"	d
INIT	honeyd_overload.c	216;"	d	file:
INITIAL	lex.c	796;"	d	file:
INORDER	getopt_long.c	93;"	d	file:
INT16_MAX	lex.c	90;"	d	file:
INT16_MIN	lex.c	81;"	d	file:
INT32_MAX	lex.c	93;"	d	file:
INT32_MIN	lex.c	84;"	d	file:
INT8_MAX	lex.c	87;"	d	file:
INT8_MIN	lex.c	78;"	d	file:
INTERNAL	parse.c	/^     INTERNAL = 330,$/;"	e	enum:yytokentype	file:
INTERNAL	parse.c	337;"	d	file:
INTERNAL	parse.h	/^     INTERNAL = 330,$/;"	e	enum:yytokentype
INTERNAL	parse.h	201;"	d
IP	parse.c	/^     IP = 318,$/;"	e	enum:yytokentype	file:
IP	parse.c	325;"	d	file:
IP	parse.h	/^     IP = 318,$/;"	e	enum:yytokentype
IP	parse.h	189;"	d
IPFRAG_MAX_FRAGS	ipfrag.h	64;"	d
IPFRAG_MAX_MEM	ipfrag.h	63;"	d
IPFRAG_TIMEOUT	ipfrag.h	61;"	d
IPSSTRING	parse.c	/^     IPSSTRING = 337,$/;"	e	enum:yytokentype	file:
IPSSTRING	parse.c	344;"	d	file:
IPSSTRING	parse.h	/^     IPSSTRING = 337,$/;"	e	enum:yytokentype
IPSSTRING	parse.h	208;"	d
IPSTRING	parse.c	/^     IPSTRING = 336,$/;"	e	enum:yytokentype	file:
IPSTRING	parse.c	343;"	d	file:
IPSTRING	parse.h	/^     IPSTRING = 336,$/;"	e	enum:yytokentype
IPSTRING	parse.h	207;"	d
IPV6_MULTICAST_ETH	icmp6.c	63;"	d	file:
IPV6_RANDOM_MODE_DEACTIVATED	honeyd.c	122;"	d	file:
LATENCY	parse.c	/^     LATENCY = 293,$/;"	e	enum:yytokentype	file:
LATENCY	parse.c	300;"	d	file:
LATENCY	parse.h	/^     LATENCY = 293,$/;"	e	enum:yytokentype
LATENCY	parse.h	164;"	d
LBRACKET	parse.c	/^     LBRACKET = 308,$/;"	e	enum:yytokentype	file:
LBRACKET	parse.c	315;"	d	file:
LBRACKET	parse.h	/^     LBRACKET = 308,$/;"	e	enum:yytokentype
LBRACKET	parse.h	179;"	d
LINELEN	honeydctl.c	91;"	d	file:
LINK	parse.c	/^     LINK = 289,$/;"	e	enum:yytokentype	file:
LINK	parse.c	296;"	d	file:
LINK	parse.h	/^     LINK = 289,$/;"	e	enum:yytokentype
LINK	parse.h	160;"	d
LIST	parse.c	/^     LIST = 321,$/;"	e	enum:yytokentype	file:
LIST	parse.c	328;"	d	file:
LIST	parse.h	/^     LIST = 321,$/;"	e	enum:yytokentype
LIST	parse.h	192;"	d
LONG	parse.c	/^     LONG = 341,$/;"	e	enum:yytokentype	file:
LONG	parse.c	348;"	d	file:
LONG	parse.h	/^     LONG = 341,$/;"	e	enum:yytokentype
LONG	parse.h	212;"	d
LOSS	parse.c	/^     LOSS = 295,$/;"	e	enum:yytokentype	file:
LOSS	parse.c	302;"	d	file:
LOSS	parse.h	/^     LOSS = 295,$/;"	e	enum:yytokentype
LOSS	parse.h	166;"	d
MAKE_CONFIG	config.c	1072;"	d	file:
MARSHAL	tagging.c	161;"	d	file:
MATCH_INT	pf_osfp.c	314;"	d	file:
MAX	pfctl_osfp.c	50;"	d	file:
MAXFDS	parse.c	/^     MAXFDS = 325,$/;"	e	enum:yytokentype	file:
MAXFDS	parse.c	332;"	d	file:
MAXFDS	parse.h	/^     MAXFDS = 325,$/;"	e	enum:yytokentype
MAXFDS	parse.h	196;"	d
MAX_INCLUDE_DEPTH	lex.c	787;"	d	file:
MAX_NUMBER_OF_IPV6_RANDOM_HOSTS	honeyd.c	124;"	d	file:
MAX_RRD_DATASRCS	rrdtool.h	46;"	d
MAX_UDP_BUFFERS	honeyd.h	293;"	d
MIN	pfctl_osfp.c	47;"	d	file:
MS	parse.c	/^     MS = 294,$/;"	e	enum:yytokentype	file:
MS	parse.c	301;"	d	file:
MS	parse.h	/^     MS = 294,$/;"	e	enum:yytokentype
MS	parse.h	165;"	d
MTUOFF	pf_osfp.c	357;"	d	file:
M_COUNTER	stats.h	/^	M_COUNTER, M_TV_START, M_TV_END, M_RECORD, M_MAX$/;"	e	enum:__anon5
M_MAX	stats.h	/^	M_COUNTER, M_TV_START, M_TV_END, M_RECORD, M_MAX$/;"	e	enum:__anon5
M_RECORD	stats.h	/^	M_COUNTER, M_TV_START, M_TV_END, M_RECORD, M_MAX$/;"	e	enum:__anon5
M_TV_END	stats.h	/^	M_COUNTER, M_TV_START, M_TV_END, M_RECORD, M_MAX$/;"	e	enum:__anon5
M_TV_START	stats.h	/^	M_COUNTER, M_TV_START, M_TV_END, M_RECORD, M_MAX$/;"	e	enum:__anon5
MergedKeyValue	pydataprocessing.h	/^struct MergedKeyValue {$/;"	s
MergedKeyValueFree	pydataprocessing.c	/^MergedKeyValueFree(struct mkvtree *tree, struct MergedKeyValue *mkv)$/;"	f
MergedKeyValueInsert	pydataprocessing.c	/^MergedKeyValueInsert(struct mkvtree *tree,$/;"	f
MergedKeyValueNew	pydataprocessing.c	/^MergedKeyValueNew(struct mkvtree *tree, u_char *key, size_t keylen)$/;"	f
NC_DOMAIN	dhcpclient.h	64;"	d
NC_GWADDR	dhcpclient.h	62;"	d
NC_HOSTADDR	dhcpclient.h	61;"	d
NC_MASK	dhcpclient.h	63;"	d
NC_NSADDR	dhcpclient.h	65;"	d
NET	parse.c	/^     NET = 290,$/;"	e	enum:yytokentype	file:
NET	parse.c	297;"	d	file:
NET	parse.h	/^     NET = 290,$/;"	e	enum:yytokentype
NET	parse.h	161;"	d
NETWORK	parse.c	/^     NETWORK = 301,$/;"	e	enum:yytokentype	file:
NETWORK	parse.c	308;"	d	file:
NETWORK	parse.h	/^     NETWORK = 301,$/;"	e	enum:yytokentype
NETWORK	parse.h	172;"	d
NET_CONTAINED	network.h	/^	NET_CONTAINED,$/;"	e	enum:net_order
NET_CONTAINS	network.h	/^	NET_CONTAINS,$/;"	e	enum:net_order
NET_DIFFTYPE	network.h	/^	NET_DIFFTYPE$/;"	e	enum:net_order
NET_EQUALS	network.h	/^	NET_EQUALS,$/;"	e	enum:net_order
NET_FOLLOWS	network.h	/^	NET_FOLLOWS,$/;"	e	enum:net_order
NET_PRECEEDS	network.h	/^	NET_PRECEEDS,$/;"	e	enum:net_order
NEW	parse.c	/^     NEW = 278,$/;"	e	enum:yytokentype	file:
NEW	parse.c	285;"	d	file:
NEW	parse.h	/^     NEW = 278,$/;"	e	enum:yytokentype
NEW	parse.h	149;"	d
NO	parse.c	/^     NO = 273,$/;"	e	enum:yytokentype	file:
NO	parse.c	280;"	d	file:
NO	parse.h	/^     NO = 273,$/;"	e	enum:yytokentype
NO	parse.h	144;"	d
NODLOPEN	acconfig.h	58;"	d
NTOHS	pf_osfp.c	38;"	d	file:
NTRIES	dhcpclient.c	96;"	d	file:
NUMBER	parse.c	/^     NUMBER = 340,$/;"	e	enum:yytokentype	file:
NUMBER	parse.c	347;"	d	file:
NUMBER	parse.h	/^     NUMBER = 340,$/;"	e	enum:yytokentype
NUMBER	parse.h	211;"	d
NUMBER_OF_ALIASES	interface.c	69;"	d	file:
OBRACKET	parse.c	/^     OBRACKET = 305,$/;"	e	enum:yytokentype	file:
OBRACKET	parse.c	312;"	d	file:
OBRACKET	parse.h	/^     OBRACKET = 305,$/;"	e	enum:yytokentype
OBRACKET	parse.h	176;"	d
OLD	parse.c	/^     OLD = 277,$/;"	e	enum:yytokentype	file:
OLD	parse.c	284;"	d	file:
OLD	parse.h	/^     OLD = 277,$/;"	e	enum:yytokentype
OLD	parse.h	148;"	d
ON	parse.c	/^     ON = 324,$/;"	e	enum:yytokentype	file:
ON	parse.c	331;"	d	file:
ON	parse.h	/^     ON = 324,$/;"	e	enum:yytokentype
ON	parse.h	195;"	d
OPEN	parse.c	/^     OPEN = 265,$/;"	e	enum:yytokentype	file:
OPEN	parse.c	272;"	d	file:
OPEN	parse.h	/^     OPEN = 265,$/;"	e	enum:yytokentype
OPEN	parse.h	136;"	d
OPTION	parse.c	/^     OPTION = 298,$/;"	e	enum:yytokentype	file:
OPTION	parse.c	305;"	d	file:
OPTION	parse.h	/^     OPTION = 298,$/;"	e	enum:yytokentype
OPTION	parse.h	169;"	d
OS	parse.c	/^     OS = 317,$/;"	e	enum:yytokentype	file:
OS	parse.c	324;"	d	file:
OS	parse.h	/^     OS = 317,$/;"	e	enum:yytokentype
OS	parse.h	188;"	d
OSFP_HASHSIZE	osfp.h	37;"	d
OSFP_TIMEOUT	osfp.h	38;"	d
OS_NUM_OSES	analyze.c	812;"	d	file:
OTHERWISE	parse.c	/^     OTHERWISE = 314,$/;"	e	enum:yytokentype	file:
OTHERWISE	parse.c	321;"	d	file:
OTHERWISE	parse.h	/^     OTHERWISE = 314,$/;"	e	enum:yytokentype
OTHERWISE	parse.h	185;"	d
PACKAGE	config.h	290;"	d
PACKAGE_BUGREPORT	config.h	293;"	d
PACKAGE_NAME	config.h	296;"	d
PACKAGE_STRING	config.h	299;"	d
PACKAGE_TARNAME	config.h	302;"	d
PACKAGE_VERSION	config.h	305;"	d
PERSONALITY	parse.c	/^     PERSONALITY = 270,$/;"	e	enum:yytokentype	file:
PERSONALITY	parse.c	277;"	d	file:
PERSONALITY	parse.h	/^     PERSONALITY = 270,$/;"	e	enum:yytokentype
PERSONALITY	parse.h	141;"	d
PF_OPT_NOACTION	pfctl_osfp.c	39;"	d	file:
PF_OPT_VERBOSE2	pfctl_osfp.c	40;"	d	file:
PF_OSFP_ANY	pfvar.h	42;"	d
PF_OSFP_DF	pfvar.h	106;"	d
PF_OSFP_ENTRY_EQ	pfvar.h	58;"	d
PF_OSFP_EXPANDED	pfvar.h	50;"	d
PF_OSFP_GENERIC	pfvar.h	51;"	d
PF_OSFP_LEN	pfvar.h	53;"	d
PF_OSFP_MAXTTL_OFFSET	pfvar.h	111;"	d
PF_OSFP_MAX_OPTS	pfvar.h	119;"	d
PF_OSFP_MSS	pfvar.h	103;"	d
PF_OSFP_MSS_DC	pfvar.h	105;"	d
PF_OSFP_MSS_MOD	pfvar.h	104;"	d
PF_OSFP_NODETAIL	pfvar.h	52;"	d
PF_OSFP_NOMATCH	pfvar.h	44;"	d
PF_OSFP_PACK	pfvar.h	77;"	d
PF_OSFP_PSIZE_DC	pfvar.h	99;"	d
PF_OSFP_PSIZE_MOD	pfvar.h	98;"	d
PF_OSFP_TCPOPT_BITS	pfvar.h	118;"	d
PF_OSFP_TCPOPT_MSS	pfvar.h	115;"	d
PF_OSFP_TCPOPT_NOP	pfvar.h	113;"	d
PF_OSFP_TCPOPT_SACK	pfvar.h	116;"	d
PF_OSFP_TCPOPT_TS	pfvar.h	117;"	d
PF_OSFP_TCPOPT_WSCALE	pfvar.h	114;"	d
PF_OSFP_TS0	pfvar.h	107;"	d
PF_OSFP_UNKNOWN	pfvar.h	43;"	d
PF_OSFP_UNPACK	pfvar.h	70;"	d
PF_OSFP_WSCALE	pfvar.h	100;"	d
PF_OSFP_WSCALE_DC	pfvar.h	102;"	d
PF_OSFP_WSCALE_MOD	pfvar.h	101;"	d
PF_OSFP_WSIZE_DC	pfvar.h	95;"	d
PF_OSFP_WSIZE_MOD	pfvar.h	94;"	d
PF_OSFP_WSIZE_MSS	pfvar.h	96;"	d
PF_OSFP_WSIZE_MTU	pfvar.h	97;"	d
PIDFILE	honeyd.h	35;"	d
POOL_PAGE_SIZE	pool.h	36;"	d
PORT	parse.c	/^     PORT = 260,$/;"	e	enum:yytokentype	file:
PORT	parse.c	267;"	d	file:
PORT	parse.h	/^     PORT = 260,$/;"	e	enum:yytokentype
PORT	parse.h	131;"	d
PORT_BLOCK	honeyd.h	/^	PORT_BLOCK,$/;"	e	enum:status
PORT_ISOPEN	honeyd.h	123;"	d
PORT_OPEN	honeyd.h	/^	PORT_OPEN = 0,$/;"	e	enum:status
PORT_PROXY	honeyd.h	/^	PORT_PROXY,$/;"	e	enum:status
PORT_PYTHON	honeyd.h	/^	PORT_PYTHON,$/;"	e	enum:status
PORT_RESERVED	honeyd.h	/^	PORT_RESERVED$/;"	e	enum:status
PORT_RESET	honeyd.h	/^	PORT_RESET,$/;"	e	enum:status
PORT_SUBSYSTEM	honeyd.h	/^	PORT_SUBSYSTEM,$/;"	e	enum:status
PORT_TARPIT	honeyd.h	139;"	d
PRINT_ERROR	getopt_long.c	84;"	d	file:
PROMPT	ui.c	67;"	d	file:
PROTECT	honeyd_overload.c	127;"	d	file:
PROTO	parse.c	/^     PROTO = 342,$/;"	e	enum:yytokentype	file:
PROTO	parse.c	349;"	d	file:
PROTO	parse.h	/^     PROTO = 342,$/;"	e	enum:yytokentype
PROTO	parse.h	213;"	d
PROXY	parse.c	/^     PROXY = 280,$/;"	e	enum:yytokentype	file:
PROXY	parse.c	287;"	d	file:
PROXY	parse.h	/^     PROXY = 280,$/;"	e	enum:yytokentype
PROXY	parse.h	151;"	d
PYEXTEND_MAX_REQUEST_SIZE	pyextend.h	44;"	d
PyConvertRecord	pydatahoneyd.c	/^PyObject* PyConvertRecord(struct record *record)$/;"	f
PyFilter	pydataprocessing.h	/^struct PyFilter {$/;"	s
PyFilterFree	pydataprocessing.c	/^PyFilterFree(struct PyFilter *filter)$/;"	f
PyFilterFromCode	pydataprocessing.c	/^PyFilterFromCode(char *code)$/;"	f
PyFilterRun	pydataprocessing.c	/^PyFilterRun(struct PyFilter *filter, PyObject *record)$/;"	f
PyMapData	pydataprocessing.c	/^PyMapData(struct mkvtree *tree, struct PyFilter *filter, PyObject* input)$/;"	f
PyMapFunction	pydataprocessing.h	/^struct PyMapFunction {$/;"	s
PyMarshalToString	pydataprocessing.c	/^PyMarshalToString(PyObject *pValue, char **data, int *datlen)$/;"	f
PyUnmarshalString	pydataprocessing.c	/^PyUnmarshalString(char *input, size_t len)$/;"	f
R0	sha1.c	51;"	d	file:
R1	sha1.c	52;"	d	file:
R2	sha1.c	53;"	d	file:
R3	sha1.c	54;"	d	file:
R4	sha1.c	55;"	d	file:
RANDOM	parse.c	/^     RANDOM = 271,$/;"	e	enum:yytokentype	file:
RANDOM	parse.c	278;"	d	file:
RANDOM	parse.h	/^     RANDOM = 271,$/;"	e	enum:yytokentype
RANDOM	parse.h	142;"	d
RANDOMEXCLUDE	parse.c	/^     RANDOMEXCLUDE = 332,$/;"	e	enum:yytokentype	file:
RANDOMEXCLUDE	parse.c	339;"	d	file:
RANDOMEXCLUDE	parse.h	/^     RANDOMEXCLUDE = 332,$/;"	e	enum:yytokentype
RANDOMEXCLUDE	parse.h	203;"	d
RANDOMIPVS	parse.c	/^     RANDOMIPVS = 331,$/;"	e	enum:yytokentype	file:
RANDOMIPVS	parse.c	338;"	d	file:
RANDOMIPVS	parse.h	/^     RANDOMIPVS = 331,$/;"	e	enum:yytokentype
RANDOMIPVS	parse.h	202;"	d
RANDOM_IPV6_DEFAULT_TEMPLATE	randomipv6.h	39;"	d
RBRACKET	parse.c	/^     RBRACKET = 307,$/;"	e	enum:yytokentype	file:
RBRACKET	parse.c	314;"	d	file:
RBRACKET	parse.h	/^     RBRACKET = 307,$/;"	e	enum:yytokentype
RBRACKET	parse.h	178;"	d
RECORD_STATE_NEW	tagging.h	65;"	d
REC_BYTES	tagging.h	/^	REC_BYTES,$/;"	e	enum:__anon7
REC_DST	tagging.h	/^	REC_DST,$/;"	e	enum:__anon7
REC_DST_PORT	tagging.h	/^	REC_DST_PORT,$/;"	e	enum:__anon7
REC_FLAGS	tagging.h	/^	REC_FLAGS,$/;"	e	enum:__anon7
REC_FLAG_LOCAL	tagging.h	80;"	d
REC_HASH	tagging.h	/^	REC_HASH,$/;"	e	enum:__anon7
REC_MAX_TAGS	tagging.h	/^	REC_MAX_TAGS$/;"	e	enum:__anon7
REC_OS_FP	tagging.h	/^	REC_OS_FP,$/;"	e	enum:__anon7
REC_PROTO	tagging.h	/^	REC_PROTO,$/;"	e	enum:__anon7
REC_SHOW	honeydctl.c	116;"	d	file:
REC_SRC	tagging.h	/^	REC_SRC,$/;"	e	enum:__anon7
REC_SRC_PORT	tagging.h	/^	REC_SRC_PORT,$/;"	e	enum:__anon7
REC_STATE	tagging.h	/^	REC_STATE,$/;"	e	enum:__anon7
REC_TV_END	tagging.h	/^	REC_TV_END,$/;"	e	enum:__anon7
REC_TV_START	tagging.h	/^	REC_TV_START,$/;"	e	enum:__anon7
REC_VERBOSE	honeydctl.c	117;"	d	file:
REJECT	lex.c	710;"	d	file:
RESET	parse.c	/^     RESET = 266,$/;"	e	enum:yytokentype	file:
RESET	parse.c	273;"	d	file:
RESET	parse.h	/^     RESET = 266,$/;"	e	enum:yytokentype
RESET	parse.h	137;"	d
RESTART	parse.c	/^     RESTART = 326,$/;"	e	enum:yytokentype	file:
RESTART	parse.c	333;"	d	file:
RESTART	parse.h	/^     RESTART = 326,$/;"	e	enum:yytokentype
RESTART	parse.h	197;"	d
RETSIGTYPE	config.h	308;"	d
ROL64	analyze.c	77;"	d	file:
ROR64	analyze.c	78;"	d	file:
ROUTE	parse.c	/^     ROUTE = 287,$/;"	e	enum:yytokentype	file:
ROUTE	parse.c	294;"	d	file:
ROUTE	parse.h	/^     ROUTE = 287,$/;"	e	enum:yytokentype
ROUTE	parse.h	158;"	d
ROUTER_ISENTRY	router.h	88;"	d
ROUTE_LINK	router.h	/^enum route_type {ROUTE_LINK = 0, ROUTE_NET, ROUTE_UNREACH, ROUTE_TUNNEL};$/;"	e	enum:route_type
ROUTE_NET	router.h	/^enum route_type {ROUTE_LINK = 0, ROUTE_NET, ROUTE_UNREACH, ROUTE_TUNNEL};$/;"	e	enum:route_type
ROUTE_TUNNEL	router.h	/^enum route_type {ROUTE_LINK = 0, ROUTE_NET, ROUTE_UNREACH, ROUTE_TUNNEL};$/;"	e	enum:route_type
ROUTE_UNREACH	router.h	/^enum route_type {ROUTE_LINK = 0, ROUTE_NET, ROUTE_UNREACH, ROUTE_TUNNEL};$/;"	e	enum:route_type
RVAL_BAD	personality.h	/^enum rval { RVAL_OKAY = 0, RVAL_ZERO, RVAL_BAD };$/;"	e	enum:rval
RVAL_DO	personality.c	754;"	d	file:
RVAL_OKAY	personality.h	/^enum rval { RVAL_OKAY = 0, RVAL_ZERO, RVAL_BAD };$/;"	e	enum:rval
RVAL_TRANS	personality.c	1226;"	d	file:
RVAL_ZERO	personality.h	/^enum rval { RVAL_OKAY = 0, RVAL_ZERO, RVAL_BAD };$/;"	e	enum:rval
SEQ_CLASS64K	personality.h	/^enum seqtype {SEQ_CLASS64K, SEQ_RI, SEQ_TRIVIALTIME, SEQ_RANDOM,$/;"	e	enum:seqtype
SEQ_CONSTANT	personality.h	/^	      SEQ_CONSTANT, SEQ_I800};$/;"	e	enum:seqtype
SEQ_I800	personality.h	/^	      SEQ_CONSTANT, SEQ_I800};$/;"	e	enum:seqtype
SEQ_RANDOM	personality.h	/^enum seqtype {SEQ_CLASS64K, SEQ_RI, SEQ_TRIVIALTIME, SEQ_RANDOM,$/;"	e	enum:seqtype
SEQ_RI	personality.h	/^enum seqtype {SEQ_CLASS64K, SEQ_RI, SEQ_TRIVIALTIME, SEQ_RANDOM,$/;"	e	enum:seqtype
SEQ_RI_MAX	personality.h	123;"	d
SEQ_TRIVIALTIME	personality.h	/^enum seqtype {SEQ_CLASS64K, SEQ_RI, SEQ_TRIVIALTIME, SEQ_RANDOM,$/;"	e	enum:seqtype
SEQ_TRIVIALTIME_MAX	personality.h	122;"	d
SET	parse.c	/^     SET = 268,$/;"	e	enum:yytokentype	file:
SET	parse.c	275;"	d	file:
SET	parse.h	/^     SET = 268,$/;"	e	enum:yytokentype
SET	parse.h	139;"	d
SET	personality.c	672;"	d	file:
SETBIT	bloom.c	8;"	d	file:
SETCMD	honeyd_overload.c	111;"	d	file:
SETERROR	command.c	266;"	d	file:
SETERROR	hsniff.c	755;"	d	file:
SHA1Final	sha1.c	/^void SHA1Final(u_char digest[20], SHA1_CTX *context)$/;"	f
SHA1HANDSOFF	sha1.c	21;"	d	file:
SHA1Init	sha1.c	/^void SHA1Init(SHA1_CTX *context)$/;"	f
SHA1Transform	sha1.c	/^void SHA1Transform(u_int32_t state[5], const u_char buffer[64])$/;"	f
SHA1Update	sha1.c	/^void SHA1Update(SHA1_CTX *context, const u_char *data, u_int len)$/;"	f
SHA1_DIGESTSIZE	stats.h	103;"	d
SHARED	parse.c	/^     SHARED = 300,$/;"	e	enum:yytokentype	file:
SHARED	parse.c	307;"	d	file:
SHARED	parse.h	/^     SHARED = 300,$/;"	e	enum:yytokentype
SHARED	parse.h	171;"	d
SHINGLE_MAX	tagging.h	39;"	d
SHINGLE_MIN	tagging.h	38;"	d
SHINGLE_SIZE	tagging.h	40;"	d
SIG_COMPRESSED_DATA	stats.h	/^	SIG_NAME, SIG_DIGEST, SIG_DATA, SIG_COMPRESSED_DATA, SIG_MAX$/;"	e	enum:__anon6
SIG_DATA	stats.h	/^	SIG_NAME, SIG_DIGEST, SIG_DATA, SIG_COMPRESSED_DATA, SIG_MAX$/;"	e	enum:__anon6
SIG_DIGEST	stats.h	/^	SIG_NAME, SIG_DIGEST, SIG_DATA, SIG_COMPRESSED_DATA, SIG_MAX$/;"	e	enum:__anon6
SIG_MAX	stats.h	/^	SIG_NAME, SIG_DIGEST, SIG_DATA, SIG_COMPRESSED_DATA, SIG_MAX$/;"	e	enum:__anon6
SIG_NAME	stats.h	/^	SIG_NAME, SIG_DIGEST, SIG_DATA, SIG_COMPRESSED_DATA, SIG_MAX$/;"	e	enum:__anon6
SIZE_OF_IPV6_FRAGMENT_HEADER	honeyd.c	125;"	d	file:
SLASH	parse.c	/^     SLASH = 292,$/;"	e	enum:yytokentype	file:
SLASH	parse.c	299;"	d	file:
SLASH	parse.h	/^     SLASH = 292,$/;"	e	enum:yytokentype
SLASH	parse.h	163;"	d
SMART_MSS	pf_osfp.c	345;"	d	file:
SMART_MTU	pf_osfp.c	358;"	d	file:
SOCKET_LOCAL	subsystem.c	91;"	d	file:
SOCKET_MAYBELOCAL	subsystem.c	92;"	d	file:
SOCKET_REMOTE	subsystem.c	90;"	d	file:
SOURCE	parse.c	/^     SOURCE = 316,$/;"	e	enum:yytokentype	file:
SOURCE	parse.c	323;"	d	file:
SOURCE	parse.h	/^     SOURCE = 316,$/;"	e	enum:yytokentype
SOURCE	parse.h	187;"	d
SPOOF	parse.c	/^     SPOOF = 302,$/;"	e	enum:yytokentype	file:
SPOOF	parse.c	309;"	d	file:
SPOOF	parse.h	/^     SPOOF = 302,$/;"	e	enum:yytokentype
SPOOF	parse.h	173;"	d
STATS_MAX_HASHES	stats.h	69;"	d
STATS_MAX_SIZE	stats.h	70;"	d
STATS_MEASUREMENT_INTERVAL	stats.h	73;"	d
STATS_SEND_TIMEOUT	stats.h	72;"	d
STATS_TIMEOUT	stats.h	71;"	d
STDC_HEADERS	config.h	311;"	d
STRING	parse.c	/^     STRING = 334,$/;"	e	enum:yytokentype	file:
STRING	parse.c	341;"	d	file:
STRING	parse.h	/^     STRING = 334,$/;"	e	enum:yytokentype
STRING	parse.h	205;"	d
SUBMISSION	parse.c	/^     SUBMISSION = 333,$/;"	e	enum:yytokentype	file:
SUBMISSION	parse.c	340;"	d	file:
SUBMISSION	parse.h	/^     SUBMISSION = 333,$/;"	e	enum:yytokentype
SUBMISSION	parse.h	204;"	d
SUBSYSTEM	parse.c	/^     SUBSYSTEM = 297,$/;"	e	enum:yytokentype	file:
SUBSYSTEM	parse.c	304;"	d	file:
SUBSYSTEM	parse.h	/^     SUBSYSTEM = 297,$/;"	e	enum:yytokentype
SUBSYSTEM	parse.h	168;"	d
SUBSYSTEM_MAGICFD	subsystem.h	83;"	d
SUBSYSTEM_RESTART	subsystem.h	69;"	d
SUBSYSTEM_RESTART_INTERVAL	subsystem.h	77;"	d
SUBSYSTEM_SHARED	subsystem.h	68;"	d
SUB_BIND	subsystem.h	/^	SUB_BIND = 1, SUB_LISTEN, SUB_CLOSE, SUB_CONNECT, SUB_SENDTO$/;"	e	enum:subcmd
SUB_CLOSE	subsystem.h	/^	SUB_BIND = 1, SUB_LISTEN, SUB_CLOSE, SUB_CONNECT, SUB_SENDTO$/;"	e	enum:subcmd
SUB_CONNECT	subsystem.h	/^	SUB_BIND = 1, SUB_LISTEN, SUB_CLOSE, SUB_CONNECT, SUB_SENDTO$/;"	e	enum:subcmd
SUB_LISTEN	subsystem.h	/^	SUB_BIND = 1, SUB_LISTEN, SUB_CLOSE, SUB_CONNECT, SUB_SENDTO$/;"	e	enum:subcmd
SUB_SENDTO	subsystem.h	/^	SUB_BIND = 1, SUB_LISTEN, SUB_CLOSE, SUB_CONNECT, SUB_SENDTO$/;"	e	enum:subcmd
SYN	parse.c	/^     SYN = 284,$/;"	e	enum:yytokentype	file:
SYN	parse.c	291;"	d	file:
SYN	parse.h	/^     SYN = 284,$/;"	e	enum:yytokentype
SYN	parse.h	155;"	d
SingleValue	pydataprocessing.h	/^struct SingleValue {$/;"	s
TARPIT	parse.c	/^     TARPIT = 310,$/;"	e	enum:yytokentype	file:
TARPIT	parse.c	317;"	d	file:
TARPIT	parse.h	/^     TARPIT = 310,$/;"	e	enum:yytokentype
TARPIT	parse.h	181;"	d
TCP_BYTESINFLIGHT	honeyd.h	367;"	d
TCP_CHECK_SEQ_OR_ACK	honeyd.c	2773;"	d	file:
TCP_DEFAULT_SIZE	honeyd.h	37;"	d
TCP_MAX_INFLIGHT	honeyd.h	368;"	d
TCP_MAX_SEND	honeyd.h	39;"	d
TCP_MAX_SIZE	honeyd.h	38;"	d
TCP_OLEN_MSS	pf_osfp.c	64;"	d	file:
TCP_OLEN_TIMESTAMP	pf_osfp.c	65;"	d	file:
TCP_RECV_SEND_DATA	honeyd.c	2794;"	d	file:
TCP_TARPIT	honeyd.h	291;"	d
TEMPLATE	parse.c	/^     TEMPLATE = 304,$/;"	e	enum:yytokentype	file:
TEMPLATE	parse.c	311;"	d	file:
TEMPLATE	parse.h	/^     TEMPLATE = 304,$/;"	e	enum:yytokentype
TEMPLATE	parse.h	175;"	d
TEMPLATE_DYNAMIC	template.h	114;"	d
TEMPLATE_DYNAMIC_CHILD	template.h	115;"	d
TEMPLATE_EXTERNAL	template.h	113;"	d
TEMPLATE_FREE_DEALLOCATE	template.h	142;"	d
TEMPLATE_FREE_REGULAR	template.h	141;"	d
TEST	ethernet.c	5096;"	d	file:
TESTFLAG	log.c	206;"	d	file:
TEST_MAX_INT	untagging.c	418;"	d	file:
TIME	parse.c	/^     TIME = 329,$/;"	e	enum:yytokentype	file:
TIME	parse.c	336;"	d	file:
TIME	parse.h	/^     TIME = 329,$/;"	e	enum:yytokentype
TIME	parse.h	200;"	d
TIME_CORRECT	personality.c	452;"	d	file:
TIME_ENTRIES	keycount.h	58;"	d
TIME_WITH_SYS_TIME	config.h	314;"	d
TO	parse.c	/^     TO = 299,$/;"	e	enum:yytokentype	file:
TO	parse.c	306;"	d	file:
TO	parse.h	/^     TO = 299,$/;"	e	enum:yytokentype
TO	parse.h	170;"	d
TRACE	util.h	49;"	d
TRACE_RESET	util.h	59;"	d
TRACE_UNKNOWN	util.c	770;"	d	file:
TUNNEL	parse.c	/^     TUNNEL = 309,$/;"	e	enum:yytokentype	file:
TUNNEL	parse.c	316;"	d	file:
TUNNEL	parse.h	/^     TUNNEL = 309,$/;"	e	enum:yytokentype
TUNNEL	parse.h	180;"	d
TV_TO_FLOAT	pydatahoneyd.c	84;"	d	file:
T_DC	pfctl_osfp.c	145;"	d	file:
T_MOD	pfctl_osfp.c	148;"	d	file:
T_MSS	pfctl_osfp.c	146;"	d	file:
T_MTU	pfctl_osfp.c	147;"	d	file:
TimedOut	honeydctl.c	/^int TimedOut = 0;$/;"	v
Timeout	honeydctl.c	/^Timeout(int Sig)$/;"	f
UID	parse.c	/^     UID = 285,$/;"	e	enum:yytokentype	file:
UID	parse.c	292;"	d	file:
UID	parse.h	/^     UID = 285,$/;"	e	enum:yytokentype
UID	parse.h	156;"	d
UINT16_MAX	lex.c	99;"	d	file:
UINT32_MAX	lex.c	102;"	d	file:
UINT8_MAX	lex.c	96;"	d	file:
UI_FIFO	ui.h	49;"	d
UNDERSCORE	honeyd_overload.c	170;"	d	file:
UNDERSCORE	honeyd_overload.c	172;"	d	file:
UNMARSHAL	untagging.c	284;"	d	file:
UNPROTECT	honeyd_overload.c	131;"	d	file:
UNREACH	parse.c	/^     UNREACH = 291,$/;"	e	enum:yytokentype	file:
UNREACH	parse.c	298;"	d	file:
UNREACH	parse.h	/^     UNREACH = 291,$/;"	e	enum:yytokentype
UNREACH	parse.h	162;"	d
UNSPECIFIED_ADDRESS	icmp6.c	64;"	d	file:
UPTIME	parse.c	/^     UPTIME = 281,$/;"	e	enum:yytokentype	file:
UPTIME	parse.c	288;"	d	file:
UPTIME	parse.h	/^     UPTIME = 281,$/;"	e	enum:yytokentype
UPTIME	parse.h	152;"	d
USE	parse.c	/^     USE = 312,$/;"	e	enum:yytokentype	file:
USE	parse.c	319;"	d	file:
USE	parse.h	/^     USE = 312,$/;"	e	enum:yytokentype
USE	parse.h	183;"	d
VERSION	config.h	317;"	d
WHITESPACE	personality.h	59;"	d
WHITESPACE	ui.c	68;"	d	file:
XPRINT	personality.h	60;"	d
YESNO	parse.c	/^     YESNO = 339,$/;"	e	enum:yytokentype	file:
YESNO	parse.c	346;"	d	file:
YESNO	parse.h	/^     YESNO = 339,$/;"	e	enum:yytokentype
YESNO	parse.h	210;"	d
YYABORT	parse.c	1026;"	d	file:
YYACCEPT	parse.c	1025;"	d	file:
YYBACKUP	parse.c	1047;"	d	file:
YYBISON	parse.c	44;"	d	file:
YYBISON_VERSION	parse.c	47;"	d	file:
YYCASE_	parse.c	1479;"	d	file:
YYCASE_	parse.c	1489;"	d	file:
YYCOPY	parse.c	593;"	d	file:
YYCOPY	parse.c	596;"	d	file:
YYCOPY_NEEDED	parse.c	568;"	d	file:
YYDEBUG	parse.c	153;"	d	file:
YYDPRINTF	parse.c	1117;"	d	file:
YYDPRINTF	parse.c	1266;"	d	file:
YYEMPTY	parse.c	1022;"	d	file:
YYEOF	parse.c	1023;"	d	file:
YYERRCODE	parse.c	1065;"	d	file:
YYERROR	parse.c	1027;"	d	file:
YYERROR_VERBOSE	parse.c	158;"	d	file:
YYERROR_VERBOSE	parse.c	159;"	d	file:
YYERROR_VERBOSE	parse.c	161;"	d	file:
YYFAIL	parse.c	1037;"	d	file:
YYFINAL	parse.c	609;"	d	file:
YYFPRINTF	parse.c	1114;"	d	file:
YYFREE	parse.c	538;"	d	file:
YYID	parse.c	/^YYID (int yyi)$/;"	f	file:
YYID	parse.c	462;"	d	file:
YYINITDEPTH	parse.c	1275;"	d	file:
YYLAST	parse.c	611;"	d	file:
YYLEX	parse.c	1104;"	d	file:
YYLEX	parse.c	1106;"	d	file:
YYLLOC_DEFAULT	parse.c	1074;"	d	file:
YYLSP_NEEDED	parse.c	62;"	d	file:
YYMALLOC	parse.c	531;"	d	file:
YYMAXDEPTH	parse.c	1286;"	d	file:
YYMAXUTOK	parse.c	624;"	d	file:
YYNNTS	parse.c	616;"	d	file:
YYNRULES	parse.c	618;"	d	file:
YYNSTATES	parse.c	620;"	d	file:
YYNTOKENS	parse.c	614;"	d	file:
YYPACT_NINF	parse.c	884;"	d	file:
YYPOPSTACK	parse.c	1650;"	d	file:
YYPULL	parse.c	59;"	d	file:
YYPURE	parse.c	53;"	d	file:
YYPUSH	parse.c	56;"	d	file:
YYRECOVERING	parse.c	1045;"	d	file:
YYRHSLOC	parse.c	1072;"	d	file:
YYSIZE_MAXIMUM	parse.c	439;"	d	file:
YYSIZE_T	parse.c	427;"	d	file:
YYSIZE_T	parse.c	429;"	d	file:
YYSIZE_T	parse.c	433;"	d	file:
YYSIZE_T	parse.c	435;"	d	file:
YYSKELETON_NAME	parse.c	50;"	d	file:
YYSTACK_ALLOC	parse.c	485;"	d	file:
YYSTACK_ALLOC	parse.c	489;"	d	file:
YYSTACK_ALLOC	parse.c	494;"	d	file:
YYSTACK_ALLOC	parse.c	517;"	d	file:
YYSTACK_ALLOC_MAXIMUM	parse.c	514;"	d	file:
YYSTACK_ALLOC_MAXIMUM	parse.c	520;"	d	file:
YYSTACK_BYTES	parse.c	564;"	d	file:
YYSTACK_FREE	parse.c	508;"	d	file:
YYSTACK_FREE	parse.c	518;"	d	file:
YYSTACK_GAP_MAXIMUM	parse.c	560;"	d	file:
YYSTACK_RELOCATE	parse.c	575;"	d	file:
YYSTATE	lex.c	151;"	d	file:
YYSTYPE	parse.c	/^typedef union YYSTYPE$/;"	u	file:
YYSTYPE	parse.c	/^} YYSTYPE;$/;"	t	typeref:union:YYSTYPE	file:
YYSTYPE	parse.h	/^typedef union YYSTYPE$/;"	u
YYSTYPE	parse.h	/^} YYSTYPE;$/;"	t	typeref:union:YYSTYPE
YYSTYPE_IS_DECLARED	parse.c	384;"	d	file:
YYSTYPE_IS_DECLARED	parse.h	248;"	d
YYSTYPE_IS_TRIVIAL	parse.c	382;"	d	file:
YYSTYPE_IS_TRIVIAL	parse.h	246;"	d
YYTABLES_NAME	lex.c	2574;"	d	file:
YYTABLE_NINF	parse.c	926;"	d	file:
YYTERROR	parse.c	1064;"	d	file:
YYTEXT_POINTER	config.h	321;"	d
YYTOKENTYPE	parse.c	172;"	d	file:
YYTOKENTYPE	parse.h	36;"	d
YYTOKEN_TABLE	parse.c	166;"	d	file:
YYTRANSLATE	parse.c	626;"	d	file:
YYUNDEFTOK	parse.c	623;"	d	file:
YYUSE	parse.c	455;"	d	file:
YYUSE	parse.c	457;"	d	file:
YY_	parse.c	445;"	d	file:
YY_	parse.c	449;"	d	file:
YY_AT_BOL	lex.c	358;"	d	file:
YY_BREAK	lex.c	968;"	d	file:
YY_BUFFER_EOF_PENDING	lex.c	274;"	d	file:
YY_BUFFER_NEW	lex.c	262;"	d	file:
YY_BUFFER_NORMAL	lex.c	263;"	d	file:
YY_BUFFER_STATE	lex.c	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	typeref:struct:yy_buffer_state	file:
YY_BUF_SIZE	lex.c	168;"	d	file:
YY_BUF_SIZE	lex.c	170;"	d	file:
YY_CHAR	lex.c	/^typedef unsigned char YY_CHAR;$/;"	t	file:
YY_CURRENT_BUFFER	lex.c	290;"	d	file:
YY_CURRENT_BUFFER_LVALUE	lex.c	297;"	d	file:
YY_DECL	lex.c	956;"	d	file:
YY_DECL_IS_OURS	lex.c	952;"	d	file:
YY_DO_BEFORE_ACTION	lex.c	383;"	d	file:
YY_END_OF_BUFFER	lex.c	391;"	d	file:
YY_END_OF_BUFFER_CHAR	lex.c	159;"	d	file:
YY_EXIT_FAILURE	lex.c	2372;"	d	file:
YY_EXTRA_TYPE	lex.c	808;"	d	file:
YY_FATAL_ERROR	lex.c	943;"	d	file:
YY_FLEX_MAJOR_VERSION	lex.c	28;"	d	file:
YY_FLEX_MINOR_VERSION	lex.c	29;"	d	file:
YY_FLEX_SUBMINOR_VERSION	lex.c	30;"	d	file:
YY_FLUSH_BUFFER	lex.c	326;"	d	file:
YY_INPUT	lex.c	896;"	d	file:
YY_INT_ALIGNED	lex.c	4;"	d	file:
YY_LESS_LINENO	lex.c	191;"	d	file:
YY_LOCATION_PRINT	parse.c	1097;"	d	file:
YY_MORE_ADJ	lex.c	712;"	d	file:
YY_NEW_FILE	lex.c	157;"	d	file:
YY_NULL	lex.c	131;"	d	file:
YY_NUM_RULES	lex.c	390;"	d	file:
YY_READ_BUF_SIZE	lex.c	878;"	d	file:
YY_READ_BUF_SIZE	lex.c	880;"	d	file:
YY_REDUCE_PRINT	parse.c	1256;"	d	file:
YY_REDUCE_PRINT	parse.c	1269;"	d	file:
YY_RESTORE_YY_MORE_OFFSET	lex.c	713;"	d	file:
YY_RULE_SETUP	lex.c	971;"	d	file:
YY_SC_TO_UI	lex.c	138;"	d	file:
YY_STACK_PRINT	parse.c	1218;"	d	file:
YY_STACK_PRINT	parse.c	1268;"	d	file:
YY_START	lex.c	150;"	d	file:
YY_START_STACK_INCR	lex.c	938;"	d	file:
YY_STATE_BUF_SIZE	lex.c	176;"	d	file:
YY_STATE_EOF	lex.c	154;"	d	file:
YY_STRUCT_YY_BUFFER_STATE	lex.c	215;"	d	file:
YY_SYMBOL_PRINT	parse.c	1123;"	d	file:
YY_SYMBOL_PRINT	parse.c	1267;"	d	file:
YY_TYPEDEF_YY_BUFFER_STATE	lex.c	179;"	d	file:
YY_TYPEDEF_YY_SIZE_T	lex.c	210;"	d	file:
YY_USER_ACTION	lex.c	963;"	d	file:
YY_USE_CONST	lex.c	112;"	d	file:
YY_USE_CONST	lex.c	119;"	d	file:
_ANALYZE_H_	analyze.h	33;"	d
_ARP_	arp.h	34;"	d
_CONDITION_	condition.h	34;"	d
_DEBUG_H_	debug.h	28;"	d
_DHCPCLIENT_H	dhcpclient.h	59;"	d
_ETHERNET_	ethernet.h	34;"	d
_FDPASS_H_	fdpass.h	29;"	d
_FILTER_H_	filter.h	33;"	d
_FP_CLASS_BITS	pfvar.h	67;"	d
_FP_RESERVED_BIT	pfvar.h	65;"	d
_FP_SUBTYPE_BITS	pfvar.h	69;"	d
_FP_UNUSED_BITS	pfvar.h	66;"	d
_FP_VERSION_BITS	pfvar.h	68;"	d
_GNU_SOURCE	command.c	50;"	d	file:
_GNU_SOURCE	parse.c	81;"	d	file:
_GNU_SOURCE	util.c	75;"	d	file:
_GRE_	gre.h	34;"	d
_HISTOGRAM_H_	histogram.h	33;"	d
_HONEYDSTATS_H_	honeydstats.h	33;"	d
_HONEYD_H_	honeyd.h	33;"	d
_HONEYD_OVERLOAD_H_	honeyd_overload.h	34;"	d
_HOOKS_H_	hooks.h	59;"	d
_HSNIFF_H_	hsniff.h	33;"	d
_ICMP6_	icmp6.h	35;"	d
_ICMP6_	ndp.h	2;"	d
_INTERFACE_	interface.h	34;"	d
_IP6FRAG_H_	ip6frag.h	35;"	d
_IPFRAG_H_	ipfrag.h	33;"	d
_KEYCOUNT_H_	keycount.h	33;"	d
_LOG_	log.h	34;"	d
_NETWORK_H_	network.h	33;"	d
_NET_PFVAR_H_	pfvar.h	34;"	d
_OSFP_H_	osfp.h	33;"	d
_PARSER_H_	parser.h	33;"	d
_PERSONALITY_H_	personality.h	33;"	d
_PLUGINS_CONFIG_H_	plugins_config.h	59;"	d
_PLUGINS_H_	plugins.h	59;"	d
_POOL_	pool.h	34;"	d
_PYDATAHONEYD_	pydatahoneyd.h	34;"	d
_PYDATAPROCESSING_	pydataprocessing.h	34;"	d
_PYEXTEND_	pyextend.h	34;"	d
_RANDOMIPV6_	randomipv6.h	35;"	d
_ROUTER_H_	router.h	33;"	d
_RRDTOOL_	rrdtool.h	34;"	d
_STATS_	stats.h	34;"	d
_SUBSYSTEM_H_	subsystem.h	33;"	d
_TAGGING_	tagging.h	34;"	d
_TCP_H_	tcp.h	33;"	d
_TEMPLATE_	template.h	34;"	d
_UDP_H_	udp.h	33;"	d
_UI_H_	ui.h	33;"	d
_UNTAGGING_	untagging.h	34;"	d
_UPDATE_H_	update.h	33;"	d
_UTIL_H_	util.h	34;"	d
_XOPEN_SOURCE	parse.c	80;"	d	file:
_XPROBE_ASSOC_H_	xprobe_assoc.h	58;"	d
__BLOOM_H__	bloom.h	2;"	d
__STDC_LIMIT_MACROS	lex.c	58;"	d	file:
_bcast	dhcpclient.c	/^static int _bcast(struct template *tmpl,$/;"	f	file:
_buf	tagging.c	/^struct evbuffer *_buf;$/;"	v	typeref:struct:evbuffer
_dhcp_reply	dhcpclient.c	/^static void _dhcp_reply(struct template *tmpl, u_char *buf, size_t buflen)$/;"	f	file:
_dhcp_timeout_cb	dhcpclient.c	/^static void _dhcp_timeout_cb(int fd, short ev, void *arg)$/;"	f	file:
_pack_release	dhcpclient.c	/^static int _pack_release(struct dhcpclient_req *req, void *buf, size_t *restlen)$/;"	f	file:
_pack_request	dhcpclient.c	/^static int _pack_request(struct dhcpclient_req *req, void *buf, size_t *restlen)$/;"	f	file:
_timeout_tv	dhcpclient.c	/^static struct timeval _timeout_tv =$/;"	v	typeref:struct:timeval	file:
_unicast	dhcpclient.c	/^static int _unicast(struct template *tmpl,$/;"	f	file:
_unittest	honeyd.c	/^struct _unittest$/;"	s	file:
_unittest	honeydstats_main.c	/^struct _unittest$/;"	s	file:
a	bloom.h	/^  unsigned char *a;$/;"	m	struct:__anon2
accept	honeyd_overload.c	/^int accept(int sock, struct sockaddr *addr, socklen_t *addrlen)$/;"	f
ackchange	personality.h	/^enum ackchange { ACK_KEEP = 0, ACK_ZERO, ACK_DECREMENT };$/;"	g
action	honeyd.h	/^	char *action;$/;"	m	struct:action
action	honeyd.h	/^	struct action action;$/;"	m	struct:port	typeref:struct:port::action
action	honeyd.h	/^struct action$/;"	s
action	parse.c	/^	struct action action;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::action	file:
action	parse.h	/^	struct action action;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::action
action_extend	honeyd.h	/^	void *action_extend;$/;"	m	struct:action
active	arp.h	/^	struct event		active;$/;"	m	struct:arp_req	typeref:struct:arp_req::event
add_fingerprint	pfctl_osfp.c	/^void add_fingerprint(int dev, int opts, struct pf_osfp_ioctl *fp)$/;"	f
add_host_to_multicast_group	icmp6.c	/^int add_host_to_multicast_group(struct addr *host, struct addr *multicast_addr)$/;"	f
add_slash	parse.c	/^add_slash(char *str) {$/;"	f
add_to_multicast_group_cache	icmp6.c	/^void add_to_multicast_group_cache(struct multicast_group *group_to_add)$/;"	f
addr	icmp6.h	/^	struct addr addr;$/;"	m	struct:addr_entry	typeref:struct:addr_entry::addr
addr	parse.c	/^	struct addr addr;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::addr	file:
addr	parse.h	/^	struct addr addr;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::addr
addr	router.h	/^	struct addr addr;		\/* IP address of router *\/$/;"	m	struct:router	typeref:struct:router::addr
addr_contained	util.c	/^addr_contained(struct addr *net, struct addr *addr)$/;"	f
addr_entry	icmp6.h	/^struct addr_entry{$/;"	s
addr_entry_compare	icmp6.c	/^static int addr_entry_compare(struct addr_entry *a, struct addr_entry *b)$/;"	f	file:
addr_family	honeyd.h	/^	int addr_family;$/;"	m	struct:tcp_con
addr_family	honeyd.h	/^	int addr_family;$/;"	m	struct:udp_con
addr_marshal	tagging.c	/^addr_marshal(struct evbuffer *evbuf, struct addr *addr)$/;"	f
addr_remove_scope_id	interface.c	/^static void addr_remove_scope_id(struct addr* ip6) {$/;"	f	file:
addr_str	randomipv6.h	/^	char *addr_str;$/;"	m	struct:rejected_ipv6_addr
addr_unmarshal	untagging.c	/^int addr_unmarshal(struct addr* addr, struct evbuffer *evbuf)$/;"	f
address_tags	tagging.h	/^} address_tags;$/;"	v	typeref:enum:__anon8
age	histogram.h	/^	uint32_t age;$/;"	m	struct:entry
ai	parse.c	/^	struct addrinfo *ai;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::addrinfo	file:
ai	parse.h	/^	struct addrinfo *ai;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::addrinfo
aitop	honeyd.h	/^	struct addrinfo *aitop;$/;"	m	struct:action	typeref:struct:action::addrinfo
alloca	parse.c	492;"	d	file:
allocate_memory_for_address	icmp6.c	/^struct addr * allocate_memory_for_address(void)$/;"	f
allocate_memory_for_eth_address	icmp6.c	/^struct addr * allocate_memory_for_eth_address(void)$/;"	f
allocate_memory_for_ipv6_address	icmp6.c	/^struct addr * allocate_memory_for_ipv6_address(void)$/;"	f
ambig	getopt_long.c	/^static const char ambig[] = "ambiguous option -- %.*s";$/;"	v	file:
analyze_country_enter	analyze.c	/^void analyze_country_enter(const struct addr *addr, const struct addr *dst)$/;"	f
analyze_country_enter_cb	analyze.c	/^void analyze_country_enter_cb(int result, char type, int count, int ttl,$/;"	f
analyze_filter_cb	analyze.c	/^void analyze_filter_cb(void *reparg, void *treearg)$/;"	f
analyze_init	analyze.c	/^void analyze_init(void)$/;"	f
analyze_os_enter	analyze.c	/^void analyze_os_enter(const struct addr *addr, const char *osfp)$/;"	f
analyze_port_enter	analyze.c	/^void analyze_port_enter(uint16_t port, const struct addr *src,$/;"	f
analyze_print_country_report	analyze.c	/^void analyze_print_country_report()$/;"	f
analyze_print_port_report	analyze.c	/^void analyze_print_port_report()$/;"	f
analyze_print_report	analyze.c	/^void analyze_print_report()$/;"	f
analyze_print_spammer_report	analyze.c	/^void analyze_print_spammer_report()$/;"	f
analyze_record	analyze.c	/^void analyze_record(const struct record *record)$/;"	f
analyze_report_cb	analyze.c	/^void analyze_report_cb(int fd, short what, void *arg)$/;"	f
analyze_set_checkpoint_doreplay	analyze.c	/^void analyze_set_checkpoint_doreplay(int doit)$/;"	f
analyze_spammer_enter	analyze.c	/^void analyze_spammer_enter(const struct addr *src, uint32_t bytes)$/;"	f
analyze_test	analyze.c	/^void analyze_test(void)$/;"	f
arg	arp.h	/^	void *arg;$/;"	m	struct:arp_req
arg	icmp6.h	/^	void *arg;$/;"	m	struct:ndp_neighbor_req
arp_discover	arp.c	/^static void arp_discover(struct arp_req *req, struct addr *ha)$/;"	f	file:
arp_discovercb	arp.c	/^static void arp_discovercb(int fd, short event, void *arg)$/;"	f	file:
arp_find	arp.c	/^arp_find(struct addr *addr)$/;"	f
arp_free	arp.c	/^void arp_free(struct arp_req *req)$/;"	f
arp_init	arp.c	/^void arp_init(void)$/;"	f
arp_new	arp.c	/^arp_new(struct interface *inter, struct addr *src_pa, struct addr *src_ha,$/;"	f
arp_recv_cb	arp.c	/^void arp_recv_cb(u_char *u, const struct pcap_pkthdr *pkthdr, const u_char *pkt)$/;"	f
arp_req	arp.h	/^struct arp_req {$/;"	s
arp_request	arp.c	/^void arp_request(struct interface *inter, struct addr *src_pa,$/;"	f
arp_send	arp.c	/^static void arp_send(eth_t *eth, int op, struct addr *sha, struct addr *spa,$/;"	f	file:
arp_timeout	arp.c	/^static void arp_timeout(int fd, short event, void *arg)$/;"	f	file:
array_contains	ip6frag.c	/^int array_contains(void *array, void *element, int element_size, int length)$/;"	f
asize	bloom.h	/^  size_t asize;$/;"	m	struct:__anon2
assemble_fragments	ip6frag.c	/^struct ip6_hdr * assemble_fragments(struct ip6_hdr *ip6, struct fragment6 *frag)$/;"	f
assert	stats.c	58;"	d	file:
assert_is_true	icmp6.c	/^void assert_is_true(int value, char * error_message)$/;"	f
assign_source_and_target_to_neighbor_entry	icmp6.c	/^struct ndp_neighbor_req* assign_source_and_target_to_neighbor_entry($/;"	f
assoc	honeyd.h	/^	char *assoc;$/;"	m	struct:config
assoc_compare	xprobe_assoc.c	/^static int assoc_compare(assoc_item *a, assoc_item *b)$/;"	f	file:
assoc_item	xprobe_assoc.h	/^struct assoc_item {$/;"	s
assoc_item	xprobe_assoc.h	/^typedef struct assoc_item     assoc_item;$/;"	t	typeref:struct:assoc_item
associations_init	xprobe_assoc.c	/^void associations_init(void)$/;"	f
atomicio	atomicio.c	/^atomicio(f, fd, _s, n)$/;"	f
author	plugins.h	/^	const char *author;$/;"	m	struct:honeyd_plugin
aux	analyze.c	/^struct aux$/;"	s	file:
aux_compare	analyze.c	/^static int aux_compare(struct auxkey *a, struct auxkey *b)$/;"	f	file:
aux_create	analyze.c	/^aux_create(void)$/;"	f
aux_enter	analyze.c	/^int aux_enter(struct aux *aux, uint32_t value)$/;"	f
aux_free	analyze.c	/^void aux_free(void *arg)$/;"	f
aux_free	keycount.h	/^	void (*aux_free)(void *);$/;"	m	struct:keycount
auxilary	keycount.h	/^	void *auxilary;$/;"	m	struct:keycount
auxkey	analyze.h	/^struct auxkey {$/;"	s
bandwidth	router.h	/^	int bandwidth;		\/* multiplier to get delay in us *\/$/;"	m	struct:link_entry
bin_path	rrdtool.h	/^	const char *bin_path; \/* path to the executeable *\/$/;"	m	struct:rrdtool_drv
bind	honeyd_overload.c	/^int bind(int s, const struct sockaddr *name, socklen_t namelen)$/;"	f
blk	sha1.c	45;"	d	file:
blk0	sha1.c	40;"	d	file:
blk0	sha1.c	43;"	d	file:
blocked_addr_bloom_filter	randomipv6.c	/^BLOOM *blocked_addr_bloom_filter;$/;"	v
bloom_add	bloom.c	/^int bloom_add(BLOOM *bloom, const char *s)$/;"	f
bloom_check	bloom.c	/^int bloom_check(BLOOM *bloom, const char *s)$/;"	f
bloom_create	bloom.c	/^BLOOM *bloom_create(size_t size) {$/;"	f
bloom_create_hash	bloom.c	/^BLOOM *bloom_create_hash(size_t size, size_t nfuncs, ...)$/;"	f
bloom_destroy	bloom.c	/^int bloom_destroy(BLOOM *bloom)$/;"	f
buf	honeyd.h	/^	u_char *buf;$/;"	m	struct:conbuffer
buf	ipfrag.c	/^static u_char buf[IP_LEN_MAX];  \/* for complete packet *\/$/;"	v	file:
buf	pyextend.c	/^	u_char *buf;$/;"	m	struct:pywrite	file:
buffer	parse.c	/^static struct evbuffer *buffer = NULL;$/;"	v	typeref:struct:evbuffer	file:
bundle	honeyd_overload.h	/^struct bundle {$/;"	s
bytes	tagging.h	/^	uint32_t bytes; \/* optional *\/$/;"	m	struct:record
bytes_to_ethernet_addr	icmp6.c	/^void bytes_to_ethernet_addr(struct addr * ethernet_addr, char * bytes)$/;"	f
bytes_to_ip6_addr	icmp6.c	/^void bytes_to_ip6_addr(struct addr * addr_struct,char * ip6_bytes)$/;"	f
c	sha1.c	/^	u_char c[64];$/;"	m	union:__anon1	file:
call_ndp_callback	icmp6.c	/^void call_ndp_callback(struct ndp_neighbor_req * req)$/;"	f
callback	honeyd.h	/^struct callback$/;"	s
callback	hooks.c	/^	HD_PacketCallback               callback;$/;"	m	struct:honeyd_packet_hook	file:
cb	arp.h	/^	void (*cb)(struct arp_req *, int, void *);$/;"	m	struct:arp_req
cb	honeyd.c	/^    void (*cb)(void);$/;"	m	struct:_unittest	file:
cb	honeydstats_main.c	/^	void (*cb)(void);$/;"	m	struct:_unittest	file:
cb	icmp6.h	/^	void (*cb)(struct ndp_neighbor_req *, int, void *);$/;"	m	struct:ndp_neighbor_req
cb	rrdtool.h	/^	void (*cb)(char *, void *);$/;"	m	struct:rrdtool_command
cb	stats.c	/^	int (*cb)(const struct record *, void *);$/;"	m	struct:statscb	file:
cb_arg	rrdtool.h	/^	void *cb_arg;$/;"	m	struct:rrdtool_command
cb_arg	stats.c	/^	void *cb_arg;$/;"	m	struct:statscb	file:
cb_connect	honeyd.h	/^	void (*cb_connect)(int, short, void *);$/;"	m	struct:callback
cb_eread	honeyd.h	/^	void (*cb_eread)(int, short, void *);$/;"	m	struct:callback
cb_read	honeyd.h	/^	void (*cb_read)(int, short, void *);$/;"	m	struct:callback
cb_tcp	tcp.c	/^struct callback cb_tcp =$/;"	v	typeref:struct:callback
cb_udp	udp.c	/^struct callback cb_udp = {$/;"	v	typeref:struct:callback
cb_write	honeyd.h	/^	void (*cb_write)(int, short, void *);$/;"	m	struct:callback
cfg	plugins_config.c	/^	struct honeyd_plugin_cfg    cfg;$/;"	m	struct:honeyd_plugin_cfgitem	typeref:struct:honeyd_plugin_cfgitem::honeyd_plugin_cfg	file:
cfg_flt	plugins_config.h	/^		float cfg_flt;$/;"	m	union:honeyd_plugin_cfg::__anon4
cfg_flt	plugins_config.h	79;"	d
cfg_int	plugins_config.h	/^		int cfg_int;$/;"	m	union:honeyd_plugin_cfg::__anon4
cfg_int	plugins_config.h	78;"	d
cfg_str	plugins_config.h	/^		char *cfg_str;$/;"	m	union:honeyd_plugin_cfg::__anon4
cfg_str	plugins_config.h	80;"	d
cfg_type	plugins_config.h	/^	enum honeyd_plugin_cfgtype cfg_type;$/;"	m	struct:honeyd_plugin_cfg	typeref:enum:honeyd_plugin_cfg::honeyd_plugin_cfgtype
cfg_u	plugins_config.h	/^	} cfg_u;$/;"	m	struct:honeyd_plugin_cfg	typeref:union:honeyd_plugin_cfg::__anon4
check_fd	honeydctl.c	/^check_fd(int sig)$/;"	f
checkpoint_doreplay	analyze.c	/^static int checkpoint_doreplay; \/* externally set by honeydstats *\/$/;"	v	file:
checkpoint_doreplay	honeydstats.c	/^static int checkpoint_doreplay = 0;$/;"	v	file:
checkpoint_evbuf	honeydstats.c	/^struct evbuffer *checkpoint_evbuf;$/;"	v	typeref:struct:evbuffer
checkpoint_fd	honeydstats.c	/^int checkpoint_fd = -1;$/;"	v
checkpoint_filename	honeydstats_main.c	/^static char *checkpoint_filename = NULL;$/;"	v	file:
checkpoint_replay	honeydstats.c	/^void checkpoint_replay(int fd)$/;"	f
checkpoint_tv	honeydstats.c	/^static struct timeval checkpoint_tv;$/;"	v	typeref:struct:timeval	file:
class_count	pfctl_osfp.c	/^int class_count;$/;"	v
classes	pfctl_osfp.c	/^struct name_list classes = LIST_HEAD_INITIALIZER(&classes);$/;"	v	typeref:struct:name_list
clone_fd	honeyd_overload.c	/^clone_fd(struct fd *ofd, int fd)$/;"	f	file:
close	honeyd_overload.c	/^int close(int fd)$/;"	f
closed	util.c	/^	int closed;$/;"	m	struct:trace	file:
cmd	honeyd.h	/^	struct command *cmd;$/;"	m	struct:port_encapsulate	typeref:struct:port_encapsulate::command
cmd	honeyd.h	/^	struct command cmd;$/;"	m	struct:tcp_con	typeref:struct:tcp_con::command
cmd	honeyd.h	/^	struct command cmd;$/;"	m	struct:udp_con	typeref:struct:udp_con::command
cmd	pyextend.c	/^	struct command *cmd;$/;"	m	struct:pystate	typeref:struct:pystate::command	file:
cmd	subsystem.h	/^	struct command cmd;$/;"	m	struct:subsystem	typeref:struct:subsystem::command
cmd	ui.c	/^	char *cmd;$/;"	m	struct:command	file:
cmd_droppriv	command.c	/^void cmd_droppriv(uid_t uid, gid_t gid)$/;"	f
cmd_environment	command.c	/^void cmd_environment(struct template *tmpl, struct tuple *hdr)$/;"	f
cmd_fork	command.c	/^int cmd_fork(struct tuple *hdr, struct command *cmd, struct template *tmpl,$/;"	f
cmd_free	command.c	/^void cmd_free(struct command *cmd)$/;"	f
cmd_perrfd	honeyd.h	264;"	d
cmd_pfd	honeyd.h	263;"	d
cmd_proxy_connect	command.c	/^int cmd_proxy_connect(struct tuple *hdr, struct command *cmd,$/;"	f
cmd_proxy_getinfo	command.c	/^cmd_proxy_getinfo(char *address, int type, short port)$/;"	f
cmd_python	command.c	/^int cmd_python(struct tuple *hdr, struct command *cmd, void *con)$/;"	f
cmd_ready_fd	command.c	/^void cmd_ready_fd(struct command *cmd, struct callback *cb, void *con)$/;"	f
cmd_setpriv	command.c	/^int cmd_setpriv(struct template *tmpl)$/;"	f
cmd_subsystem	command.c	/^int cmd_subsystem(struct template *tmpl, struct subsystem *sub, char *execcmd,$/;"	f
cmd_subsystem_connect	command.c	/^int cmd_subsystem_connect(struct tuple *hdr, struct command *cmd,$/;"	f
cmd_subsystem_connect_cb	command.c	/^static void cmd_subsystem_connect_cb(int fd, short what, void *arg)$/;"	f	file:
cmd_subsystem_localconnect	command.c	/^int cmd_subsystem_localconnect(struct tuple *hdr, struct command *cmd,$/;"	f
cmd_subsystem_schedule_connect	command.c	/^int cmd_subsystem_schedule_connect(struct tuple *hdr, struct command *cmd,$/;"	f
cmd_tcp_connect_cb	tcp.c	/^void cmd_tcp_connect_cb(int fd, short which, void *arg)$/;"	f
cmd_tcp_eread	tcp.c	/^void cmd_tcp_eread(int fd, short which, void *arg)$/;"	f
cmd_tcp_read	tcp.c	/^void cmd_tcp_read(int fd, short which, void *arg)$/;"	f
cmd_tcp_write	tcp.c	/^void cmd_tcp_write(int fd, short which, void *arg)$/;"	f
cmd_trigger_read	command.c	/^void cmd_trigger_read(struct command *cmd, int size)$/;"	f
cmd_trigger_write	command.c	/^void cmd_trigger_write(struct command *cmd, int size)$/;"	f
cmd_udp_connect_cb	udp.c	/^cmd_udp_connect_cb(int fd, short which, void *arg)$/;"	f
cmd_udp_eread	udp.c	/^cmd_udp_eread(int fd, short which, void *arg)$/;"	f
cmd_udp_read	udp.c	/^cmd_udp_read(int fd, short which, void *arg)$/;"	f
cmd_udp_write	udp.c	/^cmd_udp_write(int fd, short which, void *arg)$/;"	f
cmdstring	subsystem.h	/^	char *cmdstring;$/;"	m	struct:subsystem
cnt	arp.h	/^	int			cnt;$/;"	m	struct:arp_req
codes	ethernet.c	/^static struct ethernetcode codes[] =$/;"	v	typeref:struct:ethernetcode	file:
command	honeyd.h	/^struct command$/;"	s
command	rrdtool.h	/^	char *command;$/;"	m	struct:rrdtool_command
command	subsystem.h	/^	enum subcmd command;$/;"	m	struct:subsystem_command	typeref:enum:subsystem_command::subcmd
command	ui.c	/^struct command {$/;"	s	file:
commands	rrdtool.h	/^	commands;$/;"	m	struct:rrdtool_drv
commands	ui.c	/^struct command commands[] = {$/;"	v	typeref:struct:command
compare	ethernet.c	/^static int compare(struct etherindex *a, struct etherindex *b)$/;"	f	file:
compare	stats.c	/^compare(struct stats *a, struct stats *b)$/;"	f	file:
compiled_code	pydataprocessing.h	/^	PyObject *compiled_code;		\/* compiled Python code *\/$/;"	m	struct:PyFilter
compute_multicast_eth_addr	icmp6.c	/^void compute_multicast_eth_addr(struct addr *ip6_addr,$/;"	f
compute_solicited_node_address	icmp6.c	/^void compute_solicited_node_address(struct addr *ip6_addr, struct addr *dst)$/;"	f
con	honeyd.h	/^	void *con;$/;"	m	struct:port_encapsulate
con	pyextend.c	/^	void *con;$/;"	m	struct:pystate	file:
con_dport	honeyd.h	248;"	d
con_ip6dst	honeyd.h	246;"	d
con_ip6src	honeyd.h	245;"	d
con_ipdst	honeyd.h	244;"	d
con_ipsrc	honeyd.h	243;"	d
con_sport	honeyd.h	247;"	d
conbuffer	honeyd.h	/^struct conbuffer$/;"	s
condition	condition.h	/^struct condition$/;"	s
condition	parse.c	/^	struct condition condition;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::condition	file:
condition	parse.h	/^	struct condition condition;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::condition
condition_match_addr	condition.c	/^condition_match_addr(const struct template *tmpl, const struct ip_hdr *ip,$/;"	f
condition_match_osfp	condition.c	/^condition_match_osfp(const struct template *tmpl, const struct ip_hdr *ip,$/;"	f
condition_match_otherwise	condition.c	/^condition_match_otherwise(const struct template *tmpl, const struct ip_hdr *ip,$/;"	f
condition_match_proto	condition.c	/^condition_match_proto(const struct template *tmpl, const struct ip_hdr *ip,$/;"	f
condition_match_time	condition.c	/^condition_match_time(const struct template *tmpl, const struct ip_hdr *ip,$/;"	f
condition_time	condition.h	/^struct condition_time$/;"	s
config	honeyd.c	/^struct config config =$/;"	v	typeref:struct:config
config	honeyd.h	/^	char *config; \/* Name of configuration file *\/$/;"	m	struct:config
config	honeyd.h	/^struct config$/;"	s
config_filename	honeydstats_main.c	/^static char *config_filename = "honeydstats.config";$/;"	v	file:
config_init	config.c	/^config_init(void)$/;"	f
config_read	config.c	/^config_read(char *config)$/;"	f
conhdr	honeyd.h	/^	struct tuple conhdr;$/;"	m	struct:tcp_con	typeref:struct:tcp_con::tuple
conhdr	honeyd.h	/^	struct tuple conhdr;$/;"	m	struct:udp_con	typeref:struct:udp_con::tuple
conhdr	hsniff.h	/^	struct tuple conhdr;$/;"	m	struct:tcp_track	typeref:struct:tcp_track::tuple
conhdr	stats.h	/^	struct tuple conhdr;$/;"	m	struct:stats	typeref:struct:stats::tuple
conhdr_compare	util.c	/^conhdr_compare(struct tuple *a, struct tuple *b)$/;"	f
connect	honeyd_overload.c	/^int connect(int s, const struct sockaddr *name, socklen_t namelen)$/;"	f
connection_insert	honeyd.c	/^static void connection_insert(struct tree *tree, struct conlru *head,$/;"	f	file:
connection_remove	honeyd.c	/^static void connection_remove(struct tree *tree, struct conlru *head,$/;"	f	file:
connection_update	honeyd.c	/^static void connection_update(struct conlru *head, struct tuple *hdr)$/;"	f	file:
correlate_nmap_with_xprobe	xprobe_assoc.c	/^int correlate_nmap_with_xprobe(struct personality *pers)$/;"	f
count	ethernet.c	/^	int count;$/;"	m	struct:ethernetcode	file:
count	filter.h	/^	uint32_t count;$/;"	m	struct:filter
count	histogram.h	/^	uint32_t count;$/;"	m	struct:entry
count	histogram.h	/^struct count$/;"	s
count	keycount.h	/^	struct count *count;$/;"	m	struct:keycount	typeref:struct:keycount::count
count_entry_free	histogram.c	/^count_entry_free(struct entryq *entries)$/;"	f
count_free	histogram.c	/^count_free(struct count *count)$/;"	f
count_get_day	histogram.c	/^count_get_day(struct count *count)$/;"	f
count_get_hour	histogram.c	/^count_get_hour(struct count *count)$/;"	f
count_get_minute	histogram.c	/^count_get_minute(struct count *count)$/;"	f
count_get_sum	histogram.c	/^count_get_sum(struct entryq *entries)$/;"	f
count_get_time	histogram.c	/^count_get_time(struct timeval *tv)$/;"	f
count_increment	histogram.c	/^count_increment(struct count *count, int delta)$/;"	f
count_init	histogram.c	/^count_init(void)$/;"	f
count_internal_increment	histogram.c	/^count_internal_increment(struct count *count, struct timeval *tv, int delta)$/;"	f
count_internal_print	histogram.c	/^count_internal_print(FILE *fout, struct count *count, char *name)$/;"	f	file:
count_move_entries	histogram.c	/^count_move_entries(struct entryq *current, struct entryq *future,$/;"	f
count_new	histogram.c	/^count_new(void)$/;"	f
count_print	histogram.c	/^count_print(FILE *fout, struct count *count, char *name)$/;"	f
count_set_time	histogram.c	/^count_set_time(struct timeval *tv)$/;"	f
count_test	histogram.c	/^count_test(void)$/;"	f
count_time_ev	histogram.c	/^static struct event count_time_ev;$/;"	v	typeref:struct:event	file:
count_time_evcb	histogram.c	/^count_time_evcb(int fd, short what, void *arg)$/;"	f	file:
counter	stats.h	/^	uint32_t counter;$/;"	m	struct:measurement
countries	analyze.c	/^struct kctree countries;$/;"	v	typeref:struct:kctree
country_cache	analyze.c	/^struct kctree country_cache;$/;"	v	typeref:struct:kctree
country_key_extract	analyze.c	/^void country_key_extract(struct keycount *keycount, void **pkey,$/;"	f
country_key_print	analyze.c	/^country_key_print(void *key, size_t keylen)$/;"	f
country_report_file	analyze.c	/^char *country_report_file = NULL;$/;"	v
country_state	analyze.c	/^struct country_state$/;"	s	file:
create_command	rrdtool.h	/^	char create_command[1024]; \/* command used to create rrd *\/$/;"	m	struct:rrdtool_db
create_template	randomipv6.c	/^void create_template(char *template_name, const struct interface *inter,FILE *logfp)$/;"	f
current_state	pyextend.c	/^static struct pystate *current_state;$/;"	v	typeref:struct:pystate	file:
curtype	parse.c	/^int curtype = -1;	\/* Lex sets it to SOCK_STREAM or _DGRAM *\/$/;"	v
daemon	daemon.c	/^int daemon(nochdir, noclose)$/;"	f
dat	personality.h	/^	enum rval dat;$/;"	m	struct:persudp	typeref:enum:persudp::rval
data	honeydctl.c	/^int data = -1;$/;"	v
data	hsniff.h	/^	void *data;$/;"	m	struct:tcp_segment
data	ip6frag.h	/^	u_char *data;$/;"	m	struct:frag6ent
data	ipfrag.h	/^	u_char *data;$/;"	m	struct:fragent
data	network.h	/^	void	*data;$/;"	m	struct:network
data	pool.h	/^	void *data;$/;"	m	struct:pool_entry
datasrcs	rrdtool.h	/^	char *datasrcs[MAX_RRD_DATASRCS];$/;"	m	struct:rrdtool_db
day	analyze.h	/^	uint32_t day;$/;"	m	struct:report
daysec	condition.c	/^daysec(const struct tm *tm)$/;"	f	file:
decode_int	untagging.c	/^int decode_int(uint32_t *pnumber, struct evbuffer *evbuf)$/;"	f
decode_int_internal	untagging.c	/^static int __inline decode_int_internal(uint32_t *pnumber,$/;"	f	file:
default_opts	personality.c	/^static char *default_opts = "tnn";$/;"	v	file:
defined	dhcpclient.h	/^	short       defined;$/;"	m	struct:netconf
delay	honeyd.h	/^struct delay$/;"	s
depth	network.h	/^	uint16_t	depth;$/;"	m	struct:network
description	plugins.h	/^	const char *description;$/;"	m	struct:honeyd_plugin
destination_channel	pydataprocessing.h	/^	char *destination_channel;$/;"	m	struct:PyMapFunction
df	personality.h	/^	u_char df;$/;"	m	struct:personate
df	personality.h	/^	uint8_t df;$/;"	m	struct:persudp
dh_chaddr	dhcpclient.h	/^	uint8_t  dh_chaddr[16];$/;"	m	struct:dhcp_msg
dh_ciaddr	dhcpclient.h	/^	uint32_t dh_ciaddr;$/;"	m	struct:dhcp_msg
dh_file	dhcpclient.h	/^	char     dh_file[128];$/;"	m	struct:dhcp_msg
dh_flags	dhcpclient.h	/^	uint16_t dh_flags;$/;"	m	struct:dhcp_msg
dh_giaddr	dhcpclient.h	/^	uint32_t dh_giaddr;$/;"	m	struct:dhcp_msg
dh_hlen	dhcpclient.h	/^	uint8_t  dh_hlen;$/;"	m	struct:dhcp_msg
dh_hops	dhcpclient.h	/^	uint8_t  dh_hops;$/;"	m	struct:dhcp_msg
dh_htype	dhcpclient.h	/^	uint8_t  dh_htype;$/;"	m	struct:dhcp_msg
dh_magiccookie	dhcpclient.h	/^	uint32_t dh_magiccookie;$/;"	m	struct:dhcp_msg
dh_op	dhcpclient.h	/^	uint8_t	 dh_op;$/;"	m	struct:dhcp_msg
dh_secs	dhcpclient.h	/^	uint16_t dh_secs;$/;"	m	struct:dhcp_msg
dh_siaddr	dhcpclient.h	/^	uint32_t dh_siaddr;$/;"	m	struct:dhcp_msg
dh_sname	dhcpclient.h	/^	char     dh_sname[64];$/;"	m	struct:dhcp_msg
dh_xid	dhcpclient.h	/^	uint32_t dh_xid;$/;"	m	struct:dhcp_msg
dh_yiaddr	dhcpclient.h	/^	uint32_t dh_yiaddr;$/;"	m	struct:dhcp_msg
dhcp_abort	dhcpclient.c	/^void dhcp_abort(struct template *tmpl)$/;"	f
dhcp_getconf	dhcpclient.c	/^int dhcp_getconf(struct template *tmpl)$/;"	f
dhcp_msg	dhcpclient.h	/^struct dhcp_msg {$/;"	s
dhcp_recv_cb	dhcpclient.c	/^void dhcp_recv_cb(struct eth_hdr *eth, struct ip_hdr *ip, u_short iplen)$/;"	f
dhcp_release	dhcpclient.c	/^int dhcp_release(struct template *tmpl)$/;"	f
dhcp_req	template.h	/^	struct dhcpclient_req *dhcp_req;$/;"	m	struct:__anon9	typeref:struct:__anon9::dhcpclient_req
dhcp_template	parse.c	/^dhcp_template(struct template *tmpl, char *interface, char *mac_addr)$/;"	f	file:
dhcpclient_req	dhcpclient.h	/^struct dhcpclient_req {$/;"	s
dict_local	pydataprocessing.h	/^	PyObject *dict_local;			\/* local dictionary *\/$/;"	m	struct:PyFilter
digest	pydataprocessing.h	/^	u_char digest[SHA1_DIGESTSIZE];		\/* identifier of code *\/$/;"	m	struct:PyFilter
digest	stats.h	/^	u_char digest[SHA1_DIGESTSIZE];$/;"	m	struct:signature
digest	tagging.h	/^	u_char digest[SHINGLE_SIZE];$/;"	m	struct:hash
dir_hooks	hooks.c	/^struct hooksq  *dir_hooks[HD_DIR_MAX];$/;"	v	typeref:struct:hooksq
disallow_finscan	personality.h	/^	uint8_t disallow_finscan:1,$/;"	m	struct:personality
discover	arp.h	/^	struct event		discover;$/;"	m	struct:arp_req	typeref:struct:arp_req::event
divider	router.h	/^	int divider;		\/* value to divide by *\/$/;"	m	struct:link_entry
do_R01	sha1.c	/^do_R01(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)$/;"	f	file:
do_R2	sha1.c	/^do_R2(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)$/;"	f	file:
do_R3	sha1.c	/^do_R3(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)$/;"	f	file:
do_R4	sha1.c	/^do_R4(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)$/;"	f	file:
domain	dhcpclient.h	/^	char        domain[256];$/;"	m	struct:netconf
domain	honeyd_overload.c	/^	int domain;$/;"	m	struct:fd	file:
domain	subsystem.h	/^	int domain;$/;"	m	struct:subsystem_command
dport	honeyd.h	/^	uint16_t dport;$/;"	m	struct:tuple
drift	template.h	/^	float drift;$/;"	m	struct:__anon9
drop	parse.c	/^	struct link_drop drop;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::link_drop	file:
drop	parse.h	/^	struct link_drop drop;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::link_drop
drop_inrate	template.h	/^	uint16_t drop_inrate;$/;"	m	struct:__anon9
drop_synrate	template.h	/^	uint16_t drop_synrate;$/;"	m	struct:__anon9
droppriv	hsniff.c	/^void droppriv(uid_t uid, gid_t gid)$/;"	f
drv	rrdtool.h	/^	struct rrdtool_drv *drv;$/;"	m	struct:rrdtool_db	typeref:struct:rrdtool_db::rrdtool_drv
dst	analyze.c	/^	struct addr dst;$/;"	m	struct:country_state	typeref:struct:country_state::addr	file:
dst	analyze.c	/^	struct reporttree *dst;$/;"	m	struct:filterarg	typeref:struct:filterarg::reporttree	file:
dst	honeyd.h	/^	struct addr dst;$/;"	m	struct:delay	typeref:struct:delay::addr
dst	honeyd_overload.h	/^	struct sockaddr_in dst;$/;"	m	struct:bundle	typeref:struct:bundle::sockaddr_in
dst	router.h	/^	struct addr dst;$/;"	m	struct:link_entry	typeref:struct:link_entry::addr
dst	tagging.h	/^	struct addr dst;$/;"	m	struct:record	typeref:struct:record::addr
dst_addr	honeyd.h	/^	struct addr dst_addr;$/;"	m	struct:tuple	typeref:struct:tuple::addr
dst_addr	ip6frag.h	/^	struct addr dst_addr;$/;"	m	struct:fragment6	typeref:struct:fragment6::addr
dst_port	tagging.h	/^	uint16_t dst_port;$/;"	m	struct:record
dup	honeyd_overload.c	/^int dup(int oldfd)$/;"	f
dup2	honeyd_overload.c	/^int dup2(int oldfd, int newfd)$/;"	f
dupacks	honeyd.h	/^	uint8_t dupacks;$/;"	m	struct:tcp_con
dynamic	template.h	/^	dynamic;$/;"	m	struct:__anon9
dynamic_rulenr	template.h	/^	int dynamic_rulenr;$/;"	m	struct:__anon9
ea	dhcpclient.h	/^	eth_addr_t      ea;		\/* our own *\/$/;"	m	struct:dhcpclient_req
echotimestamp	honeyd.h	/^	uint32_t echotimestamp;$/;"	m	struct:tcp_con
enable_ipv6_random_mode	honeyd.c	/^void enable_ipv6_random_mode(float random_percentage,$/;"	f
encode_int	tagging.c	/^encode_int(struct evbuffer *evbuf, uint32_t number)$/;"	f
entries	analyze.c	/^	int entries;$/;"	m	struct:aux	file:
entries	keycount.h	/^	entries;$/;"	m	struct:timekey
entries	keycount.h	/^	struct timetree entries;$/;"	m	struct:timeseries	typeref:struct:timeseries::timetree
entries	keycount.h	/^	uint32_t entries[TIME_ENTRIES];$/;"	m	struct:timeentry
entries	pool.h	/^	SLIST_HEAD(poolq, pool_entry) entries;$/;"	m	struct:pool
entry	histogram.h	/^struct entry$/;"	s
entry_routers_ip4	router.c	/^struct network *entry_routers_ip4 = NULL;$/;"	v	typeref:struct:network
entry_routers_ip6	router.c	/^struct network *entry_routers_ip6 = NULL;$/;"	v	typeref:struct:network
err	err.c	/^err(int eval, const char *fmt, ...)$/;"	f
errors	parse.c	/^int errors = 0;$/;"	v
errx	err.c	/^errx(int eval, const char *fmt, ...)$/;"	f
etherindex	ethernet.c	/^struct etherindex$/;"	s	file:
ethernet_addr	template.h	/^	struct addr *ethernet_addr;$/;"	m	struct:__anon9	typeref:struct:__anon9::addr
ethernet_test	ethernet.c	/^void ethernet_test(void)$/;"	f
ethernetcode	ethernet.c	/^struct ethernetcode$/;"	s	file:
ethernetcode_clone	ethernet.c	/^ethernetcode_clone(struct addr *src)$/;"	f
ethernetcode_find_best	ethernet.c	/^static uint32_t ethernetcode_find_best(struct etherindex **results, int size,$/;"	f	file:
ethernetcode_find_prefix	ethernet.c	/^uint32_t ethernetcode_find_prefix(char *vendor, int random)$/;"	f
ethernetcode_index	ethernet.c	/^static int ethernetcode_index(struct ethertree *etherroot,$/;"	f	file:
ethernetcode_init	ethernet.c	/^void ethernetcode_init(void)$/;"	f
ethernetcode_make_address	ethernet.c	/^ethernetcode_make_address(char *vendor)$/;"	f
ethernetcode_test	ethernet.c	/^void ethernetcode_test(void)$/;"	f
ev	honeyd.h	/^	struct event ev;$/;"	m	struct:port_encapsulate	typeref:struct:port_encapsulate::event
ev_accept	pyextend.c	/^static struct event ev_accept;$/;"	v	typeref:struct:event	file:
ev_accept	ui.c	/^struct event ev_accept;$/;"	v	typeref:struct:event
ev_analyze	analyze.c	/^static struct event ev_analyze;$/;"	v	typeref:struct:event	file:
ev_measure	stats.c	/^	struct event ev_measure;$/;"	m	struct:statscontrol	typeref:struct:statscontrol::event	file:
ev_read	ui.h	/^	struct event ev_read;$/;"	m	struct:uiclient	typeref:struct:uiclient::event
ev_recv	honeydstats_main.c	/^static struct event ev_recv;$/;"	v	typeref:struct:event	file:
ev_send	stats.c	/^	struct event ev_send;$/;"	m	struct:statscontrol	typeref:struct:statscontrol::event	file:
ev_timeout	rrdtool.h	/^	struct event ev_timeout;$/;"	m	struct:rrdtool_drv	typeref:struct:rrdtool_drv::event
ev_timeout	stats.h	/^	struct event ev_timeout;$/;"	m	struct:stats	typeref:struct:stats::event
ev_write	ui.h	/^	struct event ev_write;$/;"	m	struct:uiclient	typeref:struct:uiclient::event
evb	pyextend.h	/^	struct bufferevent *evb;$/;"	m	struct:pyextend_request	typeref:struct:pyextend_request::bufferevent
evb	rrdtool.h	/^	struct bufferevent *evb;$/;"	m	struct:rrdtool_drv	typeref:struct:rrdtool_drv::bufferevent
evbuf	stats.h	/^	struct evbuffer *evbuf;$/;"	m	struct:stats	typeref:struct:stats::evbuffer
evbuf	stats.h	/^	struct evbuffer *evbuf;$/;"	m	struct:stats_packet	typeref:struct:stats_packet::evbuffer
evbuf_measure	stats.c	/^	struct evbuffer *evbuf_measure;$/;"	m	struct:statscontrol	typeref:struct:statscontrol::evbuffer	file:
evbuf_recv	honeydstats_main.c	/^static struct evbuffer *evbuf_recv;$/;"	v	typeref:struct:evbuffer	file:
evbuf_tmp	stats.c	/^	struct evbuffer *evbuf_tmp;$/;"	m	struct:statscontrol	typeref:struct:statscontrol::evbuffer	file:
exclude_addr_from_generator	randomipv6.c	/^void exclude_addr_from_generator(char * addr_str)$/;"	f
extract	keycount.h	/^	void (*extract)(struct keycount *, void **, size_t *);$/;"	m	struct:timeseries
fcntl	honeyd_overload.c	/^int fcntl(int fd, int cmd, ...)$/;"	f
fd	honeyd_overload.c	/^struct fd$/;"	s	file:
fd	pyextend.c	/^	int fd;$/;"	m	struct:pystate	file:
fd	pyextend.h	/^	int fd;$/;"	m	struct:pyextend_request
fd	rrdtool.h	/^	int fd;$/;"	m	struct:rrdtool_drv
fd	ui.h	/^	int fd;$/;"	m	struct:uiclient
fd_recv	honeydstats_main.c	/^static int fd_recv;$/;"	v	file:
fdconnected	honeyd.h	/^	uint8_t fdconnected :1, fdwantclose :1, fdgotfin :1, \/* if data still buffered delay shutdown *\/$/;"	m	struct:command
fdgotfin	honeyd.h	/^	uint8_t fdconnected :1, fdwantclose :1, fdgotfin :1, \/* if data still buffered delay shutdown *\/$/;"	m	struct:command
fds_refs	util.c	/^static int *fds_refs;$/;"	v	file:
fds_refsize	util.c	/^static int fds_refsize;$/;"	v	file:
fdshare_close	util.c	/^fdshare_close(int fd)$/;"	f
fdshare_dup	util.c	/^fdshare_dup(int fd)$/;"	f
fdshare_init	util.c	/^fdshare_init(int fd)$/;"	f	file:
fdshare_inspect	util.c	/^fdshare_inspect(int fd)$/;"	f
fdwantclose	honeyd.h	/^	uint8_t fdconnected :1, fdwantclose :1, fdgotfin :1, \/* if data still buffered delay shutdown *\/$/;"	m	struct:command
fgetln	util.c	/^fgetln(FILE *stream, size_t *len)$/;"	f
filename	parse.c	/^char *filename;$/;"	v
filenames	lex.c	/^char *filenames[MAX_INCLUDE_DEPTH];$/;"	v
filter	filter.h	/^struct filter {$/;"	s
filter_compare	filter.c	/^static int filter_compare(struct filter *a, struct filter *b)$/;"	f	file:
filter_create	filter.c	/^filter_create(void)$/;"	f
filter_free	filter.c	/^void filter_free(struct filtertree *filters)$/;"	f
filter_insert	filter.c	/^void filter_insert(struct filtertree *filters, uint32_t count, void *report)$/;"	f
filter_top	filter.c	/^void filter_top(struct filtertree *filters, int n, void (*cb)(void *, void *),$/;"	f
filterarg	analyze.c	/^struct filterarg$/;"	s	file:
finacked	honeyd.h	/^	uint8_t sentfin :1, finacked :1, sawwscale :1, sawtimestamp :1, unused :4;$/;"	m	struct:tcp_con
find_fd	honeyd_overload.c	/^find_fd(int fd, int flag_filter)$/;"	f	file:
find_or_create_neighbor_entry	icmp6.c	/^find_or_create_neighbor_entry(struct addr * target_ip_addr)$/;"	f
find_router_adv	icmp6.c	/^struct router_advertisement * find_router_adv()$/;"	f
find_template	icmp6.c	/^struct template *(*find_template)(const char *) = template_find; \/\/XXX we need a proper name for mocked function pointer$/;"	v	typeref:struct:find_template
fingerprint_count	pfctl_osfp.c	/^int fingerprint_count;$/;"	v
fingerprint_name_entry	pfctl_osfp.c	/^fingerprint_name_entry(struct name_list *list, char *name)$/;"	f
flags	arp.h	/^	int flags;$/;"	m	struct:arp_req
flags	honeyd.h	/^	int flags;$/;"	m	struct:action
flags	honeyd.h	/^	int flags;$/;"	m	struct:delay
flags	honeyd.h	/^	uint16_t flags; \/* Currently used for tarpitting *\/$/;"	m	struct:tcp_con
flags	honeyd_overload.c	/^	int flags;$/;"	m	struct:fd	file:
flags	personality.h	/^	struct xp_fp_flags   flags;    \/\/everything else$/;"	m	struct:xp_fingerprint	typeref:struct:xp_fingerprint::xp_fp_flags
flags	personality.h	/^	u_char flags;$/;"	m	struct:personate
flags	router.h	/^	int flags;$/;"	m	struct:router
flags	subsystem.h	/^	int flags;$/;"	m	struct:subsystem
flags	tagging.h	/^	uint32_t flags; \/* optional *\/$/;"	m	struct:record
flags	template.h	/^	int flags;$/;"	m	struct:__anon9
flex_int16_t	lex.c	/^typedef int16_t flex_int16_t;$/;"	t	file:
flex_int16_t	lex.c	/^typedef short int flex_int16_t;$/;"	t	file:
flex_int32_t	lex.c	/^typedef int flex_int32_t;$/;"	t	file:
flex_int32_t	lex.c	/^typedef int32_t flex_int32_t;$/;"	t	file:
flex_int8_t	lex.c	/^typedef int8_t flex_int8_t;$/;"	t	file:
flex_int8_t	lex.c	/^typedef signed char flex_int8_t;$/;"	t	file:
flex_uint16_t	lex.c	/^typedef uint16_t flex_uint16_t;$/;"	t	file:
flex_uint16_t	lex.c	/^typedef unsigned short int flex_uint16_t;$/;"	t	file:
flex_uint32_t	lex.c	/^typedef uint32_t flex_uint32_t;$/;"	t	file:
flex_uint32_t	lex.c	/^typedef unsigned int flex_uint32_t;$/;"	t	file:
flex_uint8_t	lex.c	/^typedef uint8_t flex_uint8_t;$/;"	t	file:
flex_uint8_t	lex.c	/^typedef unsigned char flex_uint8_t; $/;"	t	file:
floatp	parse.c	/^	float floatp;$/;"	m	union:YYSTYPE	file:
floatp	parse.h	/^	float floatp;$/;"	m	union:YYSTYPE
forceack	personality.h	/^	enum ackchange forceack;$/;"	m	struct:personate	typeref:enum:personate::ackchange
forward	honeyd.h	/^enum forward$/;"	g
fp_class_nm	pfvar.h	/^	char			fp_class_nm[PF_OSFP_LEN];$/;"	m	struct:pf_osfp_entry
fp_enflags	pfvar.h	/^	int			fp_enflags;$/;"	m	struct:pf_osfp_entry
fp_entry	pfvar.h	/^	SLIST_ENTRY(pf_osfp_entry) fp_entry;$/;"	m	struct:pf_osfp_entry
fp_flags	pfvar.h	/^	u_int16_t		fp_flags;$/;"	m	struct:pf_os_fingerprint
fp_flags	pfvar.h	/^	u_int16_t		fp_flags;$/;"	m	struct:pf_osfp_ioctl
fp_getnum	pfvar.h	/^	int			fp_getnum;	\/* DIOCOSFPGET number *\/$/;"	m	struct:pf_osfp_ioctl
fp_mss	pfvar.h	/^	u_int16_t		fp_mss;		\/* TCP MSS *\/$/;"	m	struct:pf_os_fingerprint
fp_mss	pfvar.h	/^	u_int16_t		fp_mss;		\/* TCP MSS *\/$/;"	m	struct:pf_osfp_ioctl
fp_next	pfvar.h	/^	SLIST_ENTRY(pf_os_fingerprint)	fp_next;$/;"	m	struct:pf_os_fingerprint
fp_optcnt	pfvar.h	/^	u_int8_t		fp_optcnt;	\/* TCP option count *\/$/;"	m	struct:pf_os_fingerprint
fp_optcnt	pfvar.h	/^	u_int8_t		fp_optcnt;	\/* TCP option count *\/$/;"	m	struct:pf_osfp_ioctl
fp_os	pfvar.h	/^	pf_osfp_t		fp_os;$/;"	m	struct:pf_osfp_entry
fp_os	pfvar.h	/^	struct pf_osfp_entry	fp_os;$/;"	m	struct:pf_osfp_ioctl	typeref:struct:pf_osfp_ioctl::pf_osfp_entry
fp_oses	pfvar.h	/^	SLIST_HEAD(pf_osfp_enlist, pf_osfp_entry) fp_oses; \/* list of matches *\/$/;"	m	struct:pf_os_fingerprint
fp_psize	pfvar.h	/^	u_int16_t		fp_psize;	\/* ip->ip_len *\/$/;"	m	struct:pf_os_fingerprint
fp_psize	pfvar.h	/^	u_int16_t		fp_psize;	\/* ip->ip_len *\/$/;"	m	struct:pf_osfp_ioctl
fp_scale	FPModelConverted.h	/^double fp_scale[][2] = {$/;"	v
fp_subtype_nm	pfvar.h	/^	char			fp_subtype_nm[PF_OSFP_LEN];$/;"	m	struct:pf_osfp_entry
fp_tcpopts	pfvar.h	/^	pf_tcpopts_t		fp_tcpopts;	\/* packed TCP options *\/$/;"	m	struct:pf_os_fingerprint
fp_tcpopts	pfvar.h	/^	pf_tcpopts_t		fp_tcpopts;	\/* packed TCP options *\/$/;"	m	struct:pf_osfp_ioctl
fp_ttl	pfvar.h	/^	u_int8_t		fp_ttl;		\/* IPv4 TTL *\/$/;"	m	struct:pf_os_fingerprint
fp_ttl	pfvar.h	/^	u_int8_t		fp_ttl;		\/* IPv4 TTL *\/$/;"	m	struct:pf_osfp_ioctl
fp_version_nm	pfvar.h	/^	char			fp_version_nm[PF_OSFP_LEN];$/;"	m	struct:pf_osfp_entry
fp_wscale	pfvar.h	/^	u_int8_t		fp_wscale;	\/* TCP window scaling *\/$/;"	m	struct:pf_os_fingerprint
fp_wscale	pfvar.h	/^	u_int8_t		fp_wscale;	\/* TCP window scaling *\/$/;"	m	struct:pf_osfp_ioctl
fp_wsize	pfvar.h	/^	u_int16_t		fp_wsize;	\/* TCP window size *\/$/;"	m	struct:pf_os_fingerprint
fp_wsize	pfvar.h	/^	u_int16_t		fp_wsize;	\/* TCP window size *\/$/;"	m	struct:pf_osfp_ioctl
frag6compare	ip6frag.c	/^int frag6compare(struct fragment6 *a, struct fragment6 *b)$/;"	f
frag6ent	ip6frag.h	/^struct frag6ent {$/;"	s
fragcompare	ipfrag.c	/^fragcompare(struct fragment *a, struct fragment *b)$/;"	f
fragent	ipfrag.h	/^struct fragent {$/;"	s
fraglist	ip6frag.h	/^	TAILQ_HEAD(frag6q, frag6ent) fraglist;$/;"	m	struct:fragment6
fraglist	ipfrag.h	/^	TAILQ_HEAD(fragq, fragent) fraglist;$/;"	m	struct:fragment
fragment	ipfrag.h	/^struct fragment {$/;"	s
fragment6	ip6frag.h	/^struct fragment6 {$/;"	s
fragp	ipfrag.h	/^	enum fragpolicy fragp;$/;"	m	struct:fragment	typeref:enum:fragment::fragpolicy
fragp	parse.c	/^	enum fragpolicy fragp;$/;"	m	union:YYSTYPE	typeref:enum:YYSTYPE::fragpolicy	file:
fragp	parse.h	/^	enum fragpolicy fragp;$/;"	m	union:YYSTYPE	typeref:enum:YYSTYPE::fragpolicy
fragp	personality.h	/^	enum fragpolicy fragp;$/;"	m	struct:personality	typeref:enum:personality::fragpolicy
fragpolicy	personality.h	/^enum fragpolicy {FRAG_OLD = 0, FRAG_DROP, FRAG_NEW};$/;"	g
free_fd	honeyd_overload.c	/^static void free_fd(struct fd *nfd)$/;"	f	file:
free_fragments	ip6frag.c	/^void free_fragments(struct fragment6 *frag)$/;"	f
func	ui.c	/^	int (*func)(struct evbuffer *, char *);$/;"	m	struct:command	file:
funcs	bloom.h	/^  hashfunc_t *funcs;$/;"	m	struct:__anon2
gcd	getopt_long.c	/^gcd(int a, int b)$/;"	f	file:
gcd	personality.h	/^	uint32_t gcd;$/;"	m	struct:personality
generate_mock_blocked_entries	randomipv6.c	/^void generate_mock_blocked_entries(int number_of_mocked_entries)$/;"	f
generic_connect	honeyd.c	/^void generic_connect(struct template *tmpl, struct tuple *hdr,$/;"	f
generic_timeout	honeyd.c	/^void generic_timeout(struct event *ev, int seconds)$/;"	f
generic_timeout	hsniff.c	/^void generic_timeout(struct event *ev, int seconds)$/;"	f
get_addr_family	util.c	/^get_addr_family(char * addr){$/;"	f
get_assoc	xprobe_assoc.c	/^get_assoc(FILE *fp)$/;"	f	file:
get_echoed_dtsize	personality.c	/^get_echoed_dtsize (char *input)$/;"	f	file:
get_echoed_total_len	personality.c	/^get_echoed_total_len(char *input)$/;"	f	file:
get_ext_hdr_length	honeyd.c	/^int get_ext_hdr_length(struct ip6_ext_hdr *ext_hdr) {$/;"	f
get_field	pfctl_osfp.c	/^get_field(char **line, size_t *len, int *fieldlen)$/;"	f
get_first_member_of_multicast_group	icmp6.c	/^get_first_member_of_multicast_group(struct addr * multicast_addr)$/;"	f
get_fprint	personality.c	/^get_fprint(FILE * fp_in)$/;"	f	file:
get_int	pfctl_osfp.c	/^int get_int(char **line, size_t *len, int *var, int *mod, const char *name,$/;"	f
get_ip6_next_hdr	honeyd.c	/^int get_ip6_next_hdr(u_char **next_hdr, struct ip6_hdr *ip6,$/;"	f
get_last_unfragmentable_ext_hdr	ip6frag.c	/^int get_last_unfragmentable_ext_hdr(struct ip6_hdr *ip6,$/;"	f
get_link_addr_from_neighbor_solicitation	icmp6.c	/^struct addr * get_link_addr_from_neighbor_solicitation($/;"	f
get_next_isn	personality.c	/^get_next_isn(struct template *tmpl, const struct personality *person)$/;"	f	file:
get_number_of_fragments	honeyd.c	/^u_int get_number_of_fragments(u_int iplen, u_int unfrag_fraghdr_size, u_int size_of_fragmentable_part)$/;"	f
get_ok_flipped	personality.c	/^get_ok_flipped(char *input)$/;"	f	file:
get_packet_from_hex_string	icmp6.c	/^char * get_packet_from_hex_string(char * hex_string, int packet_length_in_bytes)$/;"	f
get_size_of_unfragmentable_part	ip6frag.c	/^int get_size_of_unfragmentable_part(struct ip6_hdr *ip6)$/;"	f
get_solicited_addr_as_str	icmp6.c	/^char *get_solicited_addr_as_str(struct icmp6_hdr *icmp6)$/;"	f
get_str	pfctl_osfp.c	/^int get_str(char **line, size_t *len, char **v, const char *name, int minlen,$/;"	f
get_tcpopts	pfctl_osfp.c	/^int get_tcpopts(const char *filename, int lineno, const char *tcpopts,$/;"	f
get_yes_no	personality.c	/^get_yes_no(char *input)$/;"	f	file:
get_zero_notzero	personality.c	/^get_zero_notzero(char *input)$/;"	f	file:
get_zero_ok_bad	personality.c	/^get_zero_ok_bad(char *input)$/;"	f	file:
get_zero_one	personality.c	/^get_zero_one(char *input)$/;"	f	file:
getopt	getopt_long.c	/^getopt(int nargc, char * const *nargv, const char *options)$/;"	f
getopt_internal	getopt_long.c	/^getopt_internal(int nargc, char * const *nargv, const char *options,$/;"	f	file:
getopt_long	getopt_long.c	/^getopt_long(nargc, nargv, options, long_options, idx)$/;"	f
getopt_long_only	getopt_long.c	/^getopt_long_only(nargc, nargv, options, long_options, idx)$/;"	f
getprompt	honeydctl.c	/^getprompt(EditLine *e)$/;"	f
getsockname	honeyd_overload.c	/^int getsockname(int sock, struct sockaddr *to, socklen_t *tolen)$/;"	f
gid	template.h	/^	gid_t gid;$/;"	m	struct:__anon9
gre_decapsulate	gre.c	/^int gre_decapsulate(struct ip_hdr *oip, u_short oiplen, struct ip_hdr **pip,$/;"	f
gre_encapsulate	gre.c	/^int gre_encapsulate(ip_t *honeyd_ip, struct addr *src, struct addr *dst,$/;"	f
gre_flags	gre.h	/^	uint16_t gre_flags;$/;"	m	struct:gre_hdr
gre_hdr	gre.h	/^struct gre_hdr {$/;"	s
gre_proto	gre.h	/^	uint16_t gre_proto;$/;"	m	struct:gre_hdr
gre_reserved	gre.h	/^	uint16_t gre_reserved;		\/* Optional (RFC 2784) *\/$/;"	m	struct:gre_hdr
gre_sum	gre.h	/^	uint16_t gre_sum;		\/* Optional (RFC 2784) *\/$/;"	m	struct:gre_hdr
gt_lt	personality.h	/^	unsigned gt_lt:2;    \/\/ > == 01, < == 10$/;"	m	struct:ttl_pair
gw	router.h	/^	struct router *gw;$/;"	m	struct:router_entry	typeref:struct:router_entry::router
gwaddr	dhcpclient.h	/^	struct addr gwaddr;$/;"	m	struct:netconf	typeref:struct:netconf::addr
ha	arp.h	/^	struct addr		ha;$/;"	m	struct:arp_req	typeref:struct:arp_req::addr
ha_compare	arp.c	/^static int ha_compare(struct arp_req *a, struct arp_req *b)$/;"	f	file:
hadlastpacket	ipfrag.h	/^	u_short hadlastpacket;$/;"	m	struct:fragment
handle_echo_request	icmp6.c	/^void handle_echo_request(const struct interface *inter, struct ip6_hdr *ip6,$/;"	f
handle_neighbor_advertisement	icmp6.c	/^void handle_neighbor_advertisement(const struct interface *inter,$/;"	f
handle_neighbor_solicitation	icmp6.c	/^void handle_neighbor_solicitation(const struct interface *inter,$/;"	f
handle_router_advertisement	icmp6.c	/^void handle_router_advertisement(const struct interface *inter,$/;"	f
hash	tagging.h	/^struct hash$/;"	s
hashes	stats.h	/^	struct hashq hashes;$/;"	m	struct:stats	typeref:struct:stats::hashq
hashes	tagging.h	/^	hashes; \/* optional *\/$/;"	m	struct:record
hashfunc_t	bloom.h	/^typedef unsigned int (*hashfunc_t)(const char *);$/;"	t
hdr	honeyd.h	/^	struct icmp_hdr hdr; \/* ICMP header *\/$/;"	m	struct:icmp_mesg_mask	typeref:struct:icmp_mesg_mask::icmp_hdr
hdr	honeyd.h	/^	struct icmp_hdr hdr; \/* ICMP header *\/$/;"	m	struct:icmp_msg_inforeply	typeref:struct:icmp_msg_inforeply::icmp_hdr
hdr	honeyd.h	/^	struct icmp_hdr hdr; \/* ICMP header *\/$/;"	m	struct:icmp_msg_timestamp	typeref:struct:icmp_msg_timestamp::icmp_hdr
hdr	honeyd.h	/^	struct tuple *hdr;$/;"	m	struct:port_encapsulate	typeref:struct:port_encapsulate::tuple
high	router.h	/^	int high;$/;"	m	struct:link_drop
histogram_test	histogram.c	/^histogram_test(void)$/;"	f
hmac	honeydstats.h	/^	struct hmac_state hmac;$/;"	m	struct:honeyuser	typeref:struct:honeyuser::hmac_state
hmac	stats.c	/^	struct hmac_state hmac;$/;"	m	struct:statscontrol	typeref:struct:statscontrol::hmac_state	file:
hmac_init	stats.c	/^hmac_init(struct hmac_state *hmac, const char *key)$/;"	f
hmac_sign	stats.c	/^hmac_sign(const struct hmac_state *hmac, u_char *dst, size_t dstlen,$/;"	f
hmac_state	stats.h	/^struct hmac_state {$/;"	s
hmac_verify	stats.c	/^hmac_verify(const struct hmac_state *hmac, u_char *sign, size_t signlen,$/;"	f
honeyd_block	honeyd.c	/^int honeyd_block(struct template *tmpl, int proto, int number)$/;"	f
honeyd_contoa	util.c	/^honeyd_contoa(const struct tuple *hdr)$/;"	f
honeyd_contoa_v2	util.c	/^honeyd_contoa_v2(const struct tuple *hdr, char **source_address, char **destination_address)$/;"	f
honeyd_debug	honeyd.c	/^int honeyd_debug;$/;"	v
honeyd_debug	hsniff.c	/^int honeyd_debug;$/;"	v
honeyd_delay_callback	honeyd.c	/^void (*honeyd_delay_callback)(int, short, void *) = honeyd_delay_cb;$/;"	v
honeyd_delay_callback6	honeyd.c	/^void (*honeyd_delay_callback6)(int, short, void *) = honeyd_delay_cb6;$/;"	v
honeyd_delay_cb	honeyd.c	/^void honeyd_delay_cb(int fd, short which, void *arg)$/;"	f
honeyd_delay_cb6	honeyd.c	/^void honeyd_delay_cb6(int fd, short which, void *arg)$/;"	f
honeyd_delay_own_memory	honeyd.c	/^honeyd_delay_own_memory(struct delay *delay, struct ip_hdr *ip, u_int iplen)$/;"	f
honeyd_delay_own_memory6	honeyd.c	/^honeyd_delay_own_memory6(struct delay *delay, struct ip6_hdr *ip6, u_int iplen)$/;"	f
honeyd_delay_packet	honeyd.c	/^void honeyd_delay_packet(struct template *tmpl, struct ip_hdr *ip, u_int iplen,$/;"	f
honeyd_delay_packet46	honeyd.c	/^void honeyd_delay_packet46(struct template *tmpl, struct ip_hdr *ip,$/;"	f
honeyd_delay_packet6	honeyd.c	/^void honeyd_delay_packet6(struct template *tmpl, struct ip6_hdr *ip6,$/;"	f
honeyd_deliver_ethernet	honeyd.c	/^void honeyd_deliver_ethernet(struct interface *inter, struct addr *src_pa,$/;"	f
honeyd_deliver_ethernet6	honeyd.c	/^void honeyd_deliver_ethernet6(const struct interface *inter,$/;"	f
honeyd_disable_update	honeyd.c	/^int honeyd_disable_update = 0;$/;"	v
honeyd_disable_webserver	honeyd.c	/^int honeyd_disable_webserver = 0;$/;"	v
honeyd_dispatch	honeyd.c	/^void honeyd_dispatch(struct template *tmpl, struct ip_hdr *ip, u_short iplen)$/;"	f
honeyd_dispatch6	honeyd.c	/^void honeyd_dispatch6(struct template *tmpl, struct ip6_hdr *ip6)$/;"	f
honeyd_ether_cb	honeyd.c	/^void honeyd_ether_cb(struct arp_req * req, int success, void *arg)$/;"	f
honeyd_ether_cb46	honeyd.c	/^void honeyd_ether_cb46(const struct interface * inter,$/;"	f
honeyd_ether_cb6	honeyd.c	/^void honeyd_ether_cb6(struct ndp_neighbor_req * req, int success, void * arg)$/;"	f
honeyd_exit	honeyd.c	/^void honeyd_exit(int status)$/;"	f
honeyd_gid	honeyd.c	/^gid_t honeyd_gid = 32767;$/;"	v
honeyd_ignore_parse_errors	honeyd.c	/^int honeyd_ignore_parse_errors = 0;$/;"	v
honeyd_init	honeyd.c	/^void honeyd_init(void)$/;"	f
honeyd_init	honeyd_overload.c	/^static void honeyd_init(void)$/;"	f	file:
honeyd_input	honeyd.c	/^void honeyd_input(const struct interface *inter, struct ip_hdr *ip,$/;"	f
honeyd_input6	honeyd.c	/^void honeyd_input6(const struct interface *inter, struct ip6_hdr *ip6,$/;"	f
honeyd_ip	honeyd.c	/^static ip_t *honeyd_ip;$/;"	v	file:
honeyd_ip6_send	honeyd.c	/^void honeyd_ip6_send(u_char *pkt, u_int iplen, struct spoof spoof)$/;"	f
honeyd_ip_send	honeyd.c	/^void honeyd_ip_send(u_char *pkt, u_int iplen, struct spoof spoof)$/;"	f
honeyd_is_webserver_enabled	honeyd.c	/^honeyd_is_webserver_enabled(void)$/;"	f	file:
honeyd_log_comment	log.c	/^honeyd_log_comment(int proto, const struct tuple *hdr, const char *remark)$/;"	f	file:
honeyd_log_flowend	log.c	/^void honeyd_log_flowend(FILE *fp, int proto, const struct tuple *hdr)$/;"	f
honeyd_log_flownew	log.c	/^void honeyd_log_flownew(FILE *fp, int proto, const struct tuple *hdr)$/;"	f
honeyd_log_icmp	log.c	/^void honeyd_log_icmp(FILE *fp, int proto, const struct ip_hdr *ip, int size)$/;"	f
honeyd_log_icmp6	log.c	/^void honeyd_log_icmp6(FILE *fp, int proto, const struct ip6_hdr *ip6)$/;"	f
honeyd_log_probe	log.c	/^void honeyd_log_probe(FILE *fp, int proto, const struct tuple *hdr, int size,$/;"	f
honeyd_log_service	log.c	/^void honeyd_log_service(FILE *fp, int proto, const struct tuple *hdr,$/;"	f
honeyd_logdate	log.c	/^honeyd_logdate(void)$/;"	f
honeyd_logend	log.c	/^void honeyd_logend(FILE *logfp)$/;"	f
honeyd_logfp	honeyd.c	/^static FILE *honeyd_logfp;$/;"	v	file:
honeyd_logproto	log.c	/^honeyd_logproto(int proto)$/;"	f	file:
honeyd_logstart	log.c	/^honeyd_logstart(const char *filename)$/;"	f
honeyd_logtcpflags	log.c	/^honeyd_logtcpflags(int flags)$/;"	f	file:
honeyd_logtime	log.c	/^honeyd_logtime(void)$/;"	f	file:
honeyd_logtuple	log.c	/^honeyd_logtuple(const struct tuple *hdr)$/;"	f	file:
honeyd_long_opts	honeyd.c	/^static struct option honeyd_long_opts[] =$/;"	v	typeref:struct:option	file:
honeyd_nchildren	honeyd.c	/^int honeyd_nchildren;$/;"	v
honeyd_nconnects	honeyd.c	/^int honeyd_nconnects;$/;"	v
honeyd_needsroot	honeyd.c	/^int honeyd_needsroot; \/* Need different IDs *\/$/;"	v
honeyd_osfp_cache	osfp.c	/^honeyd_osfp_cache(const struct ip_hdr *ip)$/;"	f	file:
honeyd_osfp_cache_insert	osfp.c	/^static void honeyd_osfp_cache_insert(const struct ip_hdr *ip,$/;"	f	file:
honeyd_osfp_hash	osfp.c	/^honeyd_osfp_hash(const struct ip_hdr *ip)$/;"	f	file:
honeyd_osfp_init	osfp.c	/^int honeyd_osfp_init(const char *filename)$/;"	f
honeyd_osfp_input	osfp.c	/^void honeyd_osfp_input(struct tuple *conhdr, u_char *pkt, u_int plen, void *arg)$/;"	f
honeyd_osfp_match	osfp.c	/^int honeyd_osfp_match(const struct ip_hdr *ip, pf_osfp_t fp)$/;"	f
honeyd_osfp_name	honeydstats.c	/^char *honeyd_osfp_name(struct ip_hdr *hdr)$/;"	f
honeyd_osfp_name	osfp.c	/^honeyd_osfp_name(struct ip_hdr *ip)$/;"	f
honeyd_osfp_timeout	osfp.c	/^void honeyd_osfp_timeout(int fd, short what, void *arg)$/;"	f
honeyd_packet_hook	hooks.c	/^struct honeyd_packet_hook$/;"	s	file:
honeyd_plugin	plugins.h	/^struct honeyd_plugin$/;"	s
honeyd_plugin_cfg	plugins_config.h	/^struct honeyd_plugin_cfg$/;"	s
honeyd_plugin_cfgitem	plugins_config.c	/^struct honeyd_plugin_cfgitem {$/;"	s	file:
honeyd_plugin_cfgtype	plugins_config.h	/^enum honeyd_plugin_cfgtype$/;"	g
honeyd_port	honeyd.c	/^honeyd_port(struct template *tmpl, int proto, u_short number)$/;"	f
honeyd_protocol	honeyd.c	/^honeyd_protocol(struct template *tmpl, int proto)$/;"	f
honeyd_rand	honeyd.c	/^rand_t *honeyd_rand;$/;"	v
honeyd_recv_cb	honeyd.c	/^void honeyd_recv_cb(u_char *ag, const struct pcap_pkthdr *pkthdr,$/;"	f
honeyd_recv_cb6	honeyd.c	/^void honeyd_recv_cb6(u_char *ag, const struct pcap_pkthdr *pkthdr,$/;"	f
honeyd_route_packet	honeyd.c	/^enum forward honeyd_route_packet(struct ip_hdr *ip, u_int iplen,$/;"	f
honeyd_route_packet46	honeyd.c	/^enum forward honeyd_route_packet46(struct ip_hdr *ip, struct ip6_hdr *ip6,$/;"	f
honeyd_route_packet6	honeyd.c	/^enum forward honeyd_route_packet6(struct ip6_hdr *ip6, u_int iplen,$/;"	f
honeyd_router_drop	honeyd.c	/^static __inline int honeyd_router_drop(struct link_drop *drop,$/;"	f	file:
honeyd_rrd_cb	honeyd.c	/^void honeyd_rrd_cb(int fd, short what, void *arg)$/;"	f
honeyd_rrd_drv	honeyd.c	/^struct rrdtool_drv *honeyd_rrd_drv;$/;"	v	typeref:struct:rrdtool_drv
honeyd_rrd_ev	honeyd.c	/^struct event honeyd_rrd_ev;$/;"	v	typeref:struct:event
honeyd_rrd_start	honeyd.c	/^void honeyd_rrd_start(const char *rrdtool_path)$/;"	f
honeyd_rrdtool_path	honeyd.c	/^char *honeyd_rrdtool_path = PATH_RRDTOOL;$/;"	v
honeyd_send_normally	honeyd.c	/^static __inline void honeyd_send_normally(struct ip_hdr *ip, u_int iplen)$/;"	f	file:
honeyd_send_normally6	honeyd.c	/^void honeyd_send_normally6(struct ip6_hdr *ip6, int iplen)$/;"	f
honeyd_servicefp	honeyd.c	/^FILE *honeyd_servicefp;$/;"	v
honeyd_settcp	honeyd.c	/^void honeyd_settcp(struct tcp_con *con, struct ip_hdr *ip, struct tcp_hdr *tcp,$/;"	f
honeyd_settcp46	honeyd.c	/^void honeyd_settcp46(struct tcp_con *con, struct ip_hdr *ip,$/;"	f
honeyd_settcp6	honeyd.c	/^void honeyd_settcp6(struct tcp_con *con, struct ip6_hdr *ip6,$/;"	f
honeyd_setudp	honeyd.c	/^void honeyd_setudp(struct udp_con *con, struct ip_hdr *ip, struct ip6_hdr *ip6,$/;"	f
honeyd_show_data_dir	honeyd.c	/^int honeyd_show_data_dir;$/;"	v
honeyd_show_include_dir	honeyd.c	/^int honeyd_show_include_dir;$/;"	v
honeyd_show_usage	honeyd.c	/^int honeyd_show_usage;$/;"	v
honeyd_show_version	honeyd.c	/^int honeyd_show_version;$/;"	v
honeyd_sig	honeyd.c	/^int honeyd_sig;$/;"	v
honeyd_sigchld	honeyd.c	/^void honeyd_sigchld(int fd, short what, void *arg)$/;"	f
honeyd_sighup	honeyd.c	/^void honeyd_sighup(int fd, short what, void *arg)$/;"	f
honeyd_signal	honeyd.c	/^void honeyd_signal(int fd, short what, void *arg)$/;"	f
honeyd_sigusr	honeyd.c	/^void honeyd_sigusr(int fd, short what, void *arg)$/;"	f
honeyd_tcp_timeout	honeyd.c	/^void honeyd_tcp_timeout(int fd, short event, void *arg)$/;"	f
honeyd_tmp	honeyd.c	/^struct tcp_con honeyd_tmp;$/;"	v	typeref:struct:tcp_con
honeyd_traffic_db	honeyd.c	/^struct rrdtool_db *honeyd_traffic_db;$/;"	v	typeref:struct:rrdtool_db
honeyd_ttl	honeyd.c	/^int honeyd_ttl = HONEYD_DFL_TTL;$/;"	v
honeyd_udp_timeout	honeyd.c	/^void honeyd_udp_timeout(int fd, short event, void *arg)$/;"	f
honeyd_uid	honeyd.c	/^uid_t honeyd_uid = 32767;$/;"	v
honeyd_uptime	honeyd.c	/^struct timeval honeyd_uptime;$/;"	v	typeref:struct:timeval
honeyd_use_gid	honeyd.c	/^void honeyd_use_gid(gid_t gid)$/;"	f
honeyd_use_uid	honeyd.c	/^void honeyd_use_uid(uid_t uid)$/;"	f
honeyd_varexpand	honeyd.c	/^void honeyd_varexpand(struct tcp_con *con, char *line, u_int linesize)$/;"	f
honeyd_verify_config	honeyd.c	/^int honeyd_verify_config = 0;$/;"	v
honeyd_webserver_address	honeyd.c	/^char *honeyd_webserver_address = "127.0.0.1";$/;"	v
honeyd_webserver_fix_permissions	honeyd.c	/^int honeyd_webserver_fix_permissions = 0;$/;"	v
honeyd_webserver_port	honeyd.c	/^int honeyd_webserver_port = 80;$/;"	v
honeyd_webserver_root	honeyd.c	/^char *honeyd_webserver_root = PATH_HONEYDDATA "\/webserver\/htdocs";$/;"	v
honeydstats_sighup	honeydstats_main.c	/^void honeydstats_sighup(int fd, short what, void *arg)$/;"	f
honeydstats_signal	honeydstats_main.c	/^void honeydstats_signal(int fd, short what, void *arg)$/;"	f
honeyuser	honeydstats.h	/^struct honeyuser {$/;"	s
hooks_add_packet_hook	honeydstats.c	/^void hooks_add_packet_hook(int protocol, int dir, void *callback, void *arg)$/;"	f
hooks_add_packet_hook	hooks.c	/^hooks_add_packet_hook(int protocol, HD_Direction dir,$/;"	f
hooks_dispatch	hooks.c	/^hooks_dispatch(int protocol, HD_Direction dir, struct tuple *conhdr,$/;"	f
hooks_init	hooks.c	/^hooks_init(void)$/;"	f
hooks_remove_impl	hooks.c	/^hooks_remove_impl(struct hooksq *hooks, HD_PacketCallback callback)$/;"	f	file:
hooks_remove_packet_hook	hooks.c	/^hooks_remove_packet_hook(int protocol, HD_Direction dir,$/;"	f
hostaddr	dhcpclient.h	/^	struct addr hostaddr;$/;"	m	struct:netconf	typeref:struct:netconf::addr
hour	analyze.h	/^	uint32_t hour;$/;"	m	struct:report
hours	histogram.h	/^	struct entryq hours;$/;"	m	struct:count	typeref:struct:count::entryq
hsniff_exit	hsniff.c	/^void hsniff_exit(int status)$/;"	f
hsniff_gid	hsniff.c	/^static gid_t hsniff_gid = 32767;$/;"	v	file:
hsniff_init	hsniff.c	/^void hsniff_init(void)$/;"	f
hsniff_long_opts	hsniff.c	/^static struct option hsniff_long_opts[] =$/;"	v	typeref:struct:option	file:
hsniff_recv_cb	hsniff.c	/^void hsniff_recv_cb(u_char *ag, const struct pcap_pkthdr *pkthdr,$/;"	f
hsniff_settcp	hsniff.c	/^void hsniff_settcp(struct tcp_track *con, struct ip_hdr *ip,$/;"	f
hsniff_setudp	hsniff.c	/^void hsniff_setudp(struct udp_con *con, struct ip_hdr *ip, struct udp_hdr *udp,$/;"	f
hsniff_show_usage	hsniff.c	/^static int hsniff_show_usage;$/;"	v	file:
hsniff_show_version	hsniff.c	/^static int hsniff_show_version;$/;"	v	file:
hsniff_signal	hsniff.c	/^void hsniff_signal(int fd, short what, void *arg)$/;"	f
hsniff_tcp_timeout	hsniff.c	/^void hsniff_tcp_timeout(int fd, short event, void *arg)$/;"	f
hsniff_uid	hsniff.c	/^static uid_t hsniff_uid = 32767;$/;"	v	file:
hsniff_useudp	hsniff.c	/^static int hsniff_useudp;$/;"	v	file:
hyd_create_buffer	lex.c	/^    YY_BUFFER_STATE hyd_create_buffer  (FILE * file, int  size )$/;"	f
hyd_delete_buffer	lex.c	/^    void hyd_delete_buffer (YY_BUFFER_STATE  b )$/;"	f
hyd_flex_debug	lex.c	/^int hyd_flex_debug = 0;$/;"	v
hyd_flush_buffer	lex.c	/^    void hyd_flush_buffer (YY_BUFFER_STATE  b )$/;"	f
hyd_init_buffer	lex.c	/^    static void hyd_init_buffer  (YY_BUFFER_STATE  b, FILE * file )$/;"	f	file:
hyd_load_buffer_state	lex.c	/^static void hyd_load_buffer_state  (void)$/;"	f	file:
hyd_scan_buffer	lex.c	/^YY_BUFFER_STATE hyd_scan_buffer  (char * base, yy_size_t  size )$/;"	f
hyd_scan_bytes	lex.c	/^YY_BUFFER_STATE hyd_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )$/;"	f
hyd_scan_string	lex.c	/^YY_BUFFER_STATE hyd_scan_string (yyconst char * yystr )$/;"	f
hyd_switch_to_buffer	lex.c	/^    void hyd_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )$/;"	f
hydalloc	lex.c	/^void *hydalloc (yy_size_t  size )$/;"	f
hydensure_buffer_stack	lex.c	/^static void hydensure_buffer_stack (void)$/;"	f	file:
hydfree	lex.c	/^void hydfree (void * ptr )$/;"	f
hydget_debug	lex.c	/^int hydget_debug  (void)$/;"	f
hydget_in	lex.c	/^FILE *hydget_in  (void)$/;"	f
hydget_leng	lex.c	/^int hydget_leng  (void)$/;"	f
hydget_lineno	lex.c	/^int hydget_lineno  (void)$/;"	f
hydget_out	lex.c	/^FILE *hydget_out  (void)$/;"	f
hydget_text	lex.c	/^char *hydget_text  (void)$/;"	f
hydin	lex.c	/^FILE *hydin = (FILE *) 0, *hydout = (FILE *) 0;$/;"	v
hydleng	lex.c	/^int hydleng;$/;"	v
hydlex_destroy	lex.c	/^int hydlex_destroy  (void)$/;"	f
hydlineno	lex.c	/^int hydlineno = 1;$/;"	v
hydout	lex.c	/^FILE *hydin = (FILE *) 0, *hydout = (FILE *) 0;$/;"	v
hydpop_buffer_state	lex.c	/^void hydpop_buffer_state (void)$/;"	f
hydpush_buffer_state	lex.c	/^void hydpush_buffer_state (YY_BUFFER_STATE new_buffer )$/;"	f
hydrealloc	lex.c	/^void *hydrealloc  (void * ptr, yy_size_t  size )$/;"	f
hydrestart	lex.c	/^    void hydrestart  (FILE * input_file )$/;"	f
hydset_debug	lex.c	/^void hydset_debug (int  bdebug )$/;"	f
hydset_in	lex.c	/^void hydset_in (FILE *  in_str )$/;"	f
hydset_lineno	lex.c	/^void hydset_lineno (int  line_number )$/;"	f
hydset_out	lex.c	/^void hydset_out (FILE *  out_str )$/;"	f
hydtext	lex.c	/^char *hydtext;$/;"	v
hydwrap	lex.c	/^int hydwrap() { return 1; }$/;"	f
iamasuckyoperatingsystem	subsystem.h	/^	u_char iamasuckyoperatingsystem[256];$/;"	m	struct:sockaddr_storage
icmp	template.h	/^	struct action icmp;$/;"	m	struct:__anon9	typeref:struct:__anon9::action
icmp6_error_send	icmp6.c	/^void icmp6_error_send(struct addr *src, struct ip6_hdr *invoking_ip6, int type,$/;"	f
icmp6_recv_cb	icmp6.c	/^void icmp6_recv_cb(const struct interface * inter, struct ip6_hdr *ip6,$/;"	f
icmp6_send_neighbor_adv	icmp6.c	/^void icmp6_send_neighbor_adv(const struct interface * inter,$/;"	f
icmp6_send_neighbor_adv_mock	icmp6.c	/^void icmp6_send_neighbor_adv_mock(const struct interface * inter,$/;"	f
icmp6_send_neighbor_advertisement	icmp6.c	/^void (*icmp6_send_neighbor_advertisement)(const struct interface * inter,$/;"	v
icmp6_send_neighbor_sol	icmp6.c	/^void icmp6_send_neighbor_sol(const struct interface *inter,$/;"	f
icmp6_send_pkt	honeyd.c	/^void icmp6_send_pkt(const struct interface * inter, struct addr *src_eth,$/;"	f
icmp6_send_router_sol	icmp6.c	/^void icmp6_send_router_sol(const struct interface *inter)$/;"	f
icmp6_test	icmp6.c	/^void icmp6_test(void)$/;"	f
icmp_addrmask_reply	personality.h	/^	unsigned icmp_addrmask_reply:1;            \/\/ 1 == yes, 0 == no$/;"	m	struct:xp_fp_flags
icmp_addrmask_reply_ttl	personality.h	/^	struct ttl_pair icmp_addrmask_reply_ttl;  \/\/Module C$/;"	m	struct:xp_fp_ttlvals	typeref:struct:xp_fp_ttlvals::ttl_pair
icmp_echo_code	personality.h	/^	unsigned icmp_echo_code:1;                 \/\/ 0 == 0, 1 == !0$/;"	m	struct:xp_fp_flags
icmp_echo_df_bit	personality.h	/^	unsigned icmp_echo_df_bit:1;               \/\/ 0 == 0, 1 == !0$/;"	m	struct:xp_fp_flags
icmp_echo_ip_id	personality.h	/^	unsigned icmp_echo_ip_id:1;                \/\/ 0 == 0, 1 == !0$/;"	m	struct:xp_fp_flags
icmp_echo_reply	honeyd.c	/^void icmp_echo_reply(struct template *tmpl, struct ip_hdr *rip, uint8_t code,$/;"	f
icmp_echo_reply_ttl	personality.h	/^	struct ttl_pair icmp_echo_reply_ttl;      \/\/Module A$/;"	m	struct:xp_fp_ttlvals	typeref:struct:xp_fp_ttlvals::ttl_pair
icmp_echo_tos_bits	personality.h	/^	unsigned icmp_echo_tos_bits:1;             \/\/ 0 == 0, 1 == !0$/;"	m	struct:xp_fp_flags
icmp_error_personality	personality.c	/^icmp_error_personality(struct template *tmpl,$/;"	f
icmp_error_send	honeyd.c	/^void icmp_error_send(struct template *tmpl, struct addr *addr, uint8_t type,$/;"	f
icmp_id	honeyd.h	/^	uint16_t icmp_id; \/* identifier *\/$/;"	m	struct:icmp_mesg_mask
icmp_id	honeyd.h	/^	uint16_t icmp_id; \/* identifier *\/$/;"	m	struct:icmp_msg_timestamp
icmp_info_reply	honeyd.c	/^void icmp_info_reply(struct template *tmpl, struct ip_hdr *rip,$/;"	f
icmp_info_reply	personality.h	/^	unsigned icmp_info_reply:1;                \/\/ 1 == yes, 0 == no$/;"	m	struct:xp_fp_flags
icmp_info_reply_ttl	personality.h	/^	struct ttl_pair icmp_info_reply_ttl;      \/\/Module D$/;"	m	struct:xp_fp_ttlvals	typeref:struct:xp_fp_ttlvals::ttl_pair
icmp_mask	honeyd.h	/^	uint32_t icmp_mask; \/* address mask *\/$/;"	m	struct:icmp_mesg_mask
icmp_mask_reply	honeyd.c	/^void icmp_mask_reply(struct template *tmpl, struct ip_hdr *rip,$/;"	f
icmp_mesg_mask	honeyd.h	/^struct icmp_mesg_mask$/;"	s
icmp_msg_inforeply	honeyd.h	/^struct icmp_msg_inforeply$/;"	s
icmp_msg_timestamp	honeyd.h	/^struct icmp_msg_timestamp$/;"	s
icmp_recv_cb	honeyd.c	/^void icmp_recv_cb(struct template *tmpl, u_char *pkt, u_short pktlen)$/;"	f
icmp_send	honeyd.c	/^void icmp_send(struct template *tmpl, u_char *pkt, uint8_t tos, u_int iplen,$/;"	f
icmp_seq	honeyd.h	/^	uint16_t icmp_seq; \/* sequence number *\/$/;"	m	struct:icmp_mesg_mask
icmp_seq	honeyd.h	/^	uint16_t icmp_seq; \/* sequence number *\/$/;"	m	struct:icmp_msg_timestamp
icmp_timestamp_reply	honeyd.c	/^void icmp_timestamp_reply(struct template *tmpl, struct ip_hdr *rip,$/;"	f
icmp_timestamp_reply	personality.h	/^	unsigned icmp_timestamp_reply:1;           \/\/ 1 == yes, 0 == no$/;"	m	struct:xp_fp_flags
icmp_timestamp_reply_ttl	personality.h	/^	struct ttl_pair icmp_timestamp_reply_ttl; \/\/Module B$/;"	m	struct:xp_fp_ttlvals	typeref:struct:xp_fp_ttlvals::ttl_pair
icmp_ts_orig	honeyd.h	/^	uint32_t icmp_ts_orig; \/* originate timestamp *\/$/;"	m	struct:icmp_msg_timestamp
icmp_ts_rx	honeyd.h	/^	uint32_t icmp_ts_rx; \/* receive timestamp *\/$/;"	m	struct:icmp_msg_timestamp
icmp_ts_tx	honeyd.h	/^	uint32_t icmp_ts_tx; \/* transmit timestamp *\/$/;"	m	struct:icmp_msg_timestamp
icmp_unreach_df_bit	personality.h	/^	unsigned icmp_unreach_df_bit:1;            \/\/ [0 , 1]$/;"	m	struct:xp_fp_flags
icmp_unreach_echoed_3bit_flags	personality.h	/^	unsigned icmp_unreach_echoed_3bit_flags:2; \/\/ [OK (01), FLIPPED (10)]$/;"	m	struct:xp_fp_flags
icmp_unreach_echoed_dtsize	personality.h	/^	unsigned icmp_unreach_echoed_dtsize:3;     \/\/ [8 (001), 64 (010), >64 (100)]$/;"	m	struct:xp_fp_flags
icmp_unreach_echoed_ip_cksum	personality.h	/^	unsigned icmp_unreach_echoed_ip_cksum:3;   \/\/ [0 (001), OK (010), BAD (100)]$/;"	m	struct:xp_fp_flags
icmp_unreach_echoed_ip_id	personality.h	/^	unsigned icmp_unreach_echoed_ip_id:2;      \/\/ [OK (01), FLIPPED (10)]$/;"	m	struct:xp_fp_flags
icmp_unreach_echoed_total_len	personality.h	/^	unsigned icmp_unreach_echoed_total_len:3;  \/\/ [>20 (001), OK (010), <20 (100)]$/;"	m	struct:xp_fp_flags
icmp_unreach_echoed_udp_cksum	personality.h	/^	unsigned icmp_unreach_echoed_udp_cksum:3;  \/\/ [0 (001), OK (010), BAD (100)]$/;"	m	struct:xp_fp_flags
icmp_unreach_precedence_bits	personality.h	/^	unsigned icmp_unreach_precedence_bits:8;   \/\/ 0xc0, 0, (hex num)$/;"	m	struct:xp_fp_flags
icmp_unreach_reply_ttl	personality.h	/^	struct ttl_pair icmp_unreach_reply_ttl;   \/\/Module E$/;"	m	struct:xp_fp_ttlvals	typeref:struct:xp_fp_ttlvals::ttl_pair
ictx	stats.h	/^	SHA1_CTX ictx;$/;"	m	struct:hmac_state
id	template.h	/^	int id;$/;"	m	struct:__anon9
idseq	honeyd.h	/^	struct icmp_msg_idseq idseq; \/* ID_SEQ *\/$/;"	m	struct:icmp_msg_inforeply	typeref:struct:icmp_msg_inforeply::icmp_msg_idseq
idt	personality.h	/^	enum ipidtype idt;$/;"	m	struct:personality	typeref:enum:personality::ipidtype
if_addrbits	interface.h	/^	int if_addrbits;$/;"	m	struct:interface
if_dloff	interface.h	/^	int if_dloff;$/;"	m	struct:interface
if_ent	interface.h	/^	struct intf_entry if_ent;$/;"	m	struct:interface	typeref:struct:interface::intf_entry
if_eth	interface.h	/^	eth_t *if_eth;$/;"	m	struct:interface
if_filter	interface.h	/^	char if_filter[1024];$/;"	m	struct:interface
if_pcap	interface.h	/^	pcap_t *if_pcap;$/;"	m	struct:interface
if_recv_cb	interface.c	/^static pcap_handler if_recv_cb = NULL;$/;"	v	file:
if_recvev	interface.h	/^	struct event if_recvev;$/;"	m	struct:interface	typeref:struct:interface::event
illoptchar	getopt_long.c	/^static const char illoptchar[] = "unknown option -- %c";$/;"	v	file:
illoptstring	getopt_long.c	/^static const char illoptstring[] = "unknown option -- %s";$/;"	v	file:
import_fingerprint	pfctl_osfp.c	/^void import_fingerprint(struct pf_osfp_ioctl *fp)$/;"	f
in6_addr_to_addr	icmp6.c	/^void in6_addr_to_addr(struct addr * addr_struct,struct in6_addr * in6)$/;"	f
inbuf	ui.h	/^	struct evbuffer *inbuf;$/;"	m	struct:uiclient	typeref:struct:uiclient::evbuffer
incl	lex.c	797;"	d	file:
includes	lex.c	/^YY_BUFFER_STATE includes[MAX_INCLUDE_DEPTH];$/;"	v
includes_index	lex.c	/^int includes_index = 0;$/;"	v
incoming	honeyd.h	/^	incoming;$/;"	m	struct:udp_con
index_word	ethernet.c	/^	char *index_word;$/;"	m	struct:etherindex	file:
init	plugins.h	/^	int (*init)(void);$/;"	m	struct:honeyd_plugin
init_blocked_addr_bloom_filter	randomipv6.c	/^void init_blocked_addr_bloom_filter()$/;"	f
initalized	honeyd_overload.c	/^static int initalized;$/;"	v	file:
initialize_addresses_with_test_values	icmp6.c	/^void initialize_addresses_with_test_values(struct addr* source_mac_addr,$/;"	f
input_bytes	honeyd.h	/^	struct count *input_bytes;$/;"	m	struct:stats_network	typeref:struct:stats_network::count
insert_fragment_entry_into_existing_queue	ip6frag.c	/^void insert_fragment_entry_into_existing_queue(struct frag6ent *entry,struct fragment6 *fragment)$/;"	f
insert_into_neighbor_cache	icmp6.c	/^void insert_into_neighbor_cache(struct ndp_neighbor_req * entry)$/;"	f
inter	arp.h	/^	struct interface	*inter;$/;"	m	struct:arp_req	typeref:struct:arp_req::interface
inter	icmp6.h	/^	const struct interface * inter;$/;"	m	struct:ndp_neighbor_req	typeref:struct:ndp_neighbor_req::interface
inter	template.h	/^	struct interface *inter;$/;"	m	struct:__anon9	typeref:struct:__anon9::interface
interface	interface.h	/^struct interface$/;"	s
interface_close	interface.c	/^interface_close(struct interface *inter)$/;"	f
interface_close_all	interface.c	/^interface_close_all(void)$/;"	f
interface_count	interface.c	/^interface_count(void)$/;"	f
interface_dopoll	interface.c	/^int interface_dopoll;$/;"	v
interface_ether_filter	interface.c	/^interface_ether_filter(struct interface *inter,$/;"	f
interface_expandips	interface.c	/^interface_expandips(int naddresses, char **addresses, int dstonly)$/;"	f	file:
interface_filter	interface.c	/^char *interface_filter = NULL;$/;"	v
interface_find	interface.c	/^interface_find(char *name)$/;"	f
interface_find_addr	interface.c	/^interface_find_addr(struct addr *addr)$/;"	f
interface_find_responsible	interface.c	/^interface_find_responsible(struct addr *addr)$/;"	f
interface_get	interface.c	/^interface_get(int off)$/;"	f
interface_init	interface.c	/^interface_init(char *dev, int naddresses, char **addresses)$/;"	f
interface_initialize	interface.c	/^interface_initialize(pcap_handler cb)$/;"	f
interface_new	interface.c	/^interface_new(char *dev)$/;"	f	file:
interface_poll_recv	interface.c	/^interface_poll_recv(int fd, short type, void *arg)$/;"	f	file:
interface_prevent_init	interface.c	/^interface_prevent_init(void)$/;"	f
interface_recv	interface.c	/^interface_recv(int fd, short type, void *arg)$/;"	f	file:
interface_regular_filter	interface.c	/^interface_regular_filter(struct interface *inter,$/;"	f
interface_test	interface.c	/^interface_test(void)$/;"	f
interface_test_insert_and_find	interface.c	/^interface_test_insert_and_find(void)$/;"	f	file:
interface_verify_config	interface.c	/^int interface_verify_config = 0;$/;"	v
intf	interface.c	/^static intf_t *intf;$/;"	v	file:
ip	honeyd.h	/^	struct ip_hdr *ip;$/;"	m	struct:delay	typeref:struct:delay::ip_hdr
ip6	honeyd.h	/^	struct ip6_hdr *ip6;$/;"	m	struct:delay	typeref:struct:delay::ip6_hdr
ip6_addr_t_to_addr	icmp6.c	/^void ip6_addr_t_to_addr(struct addr *addr_struct,ip6_addr_t *ip6)$/;"	f
ip6_copy_chunk_to_fragment	honeyd.c	/^void ip6_copy_chunk_to_fragment(u_char *ip6_fragment_pkt, u_char *unfragmented_ip6_pkt,u_int fragment_size,$/;"	f
ip6_delay_ethernet	honeyd.c	/^void ip6_delay_ethernet(struct delay *delay)$/;"	f
ip6_delay_external	honeyd.c	/^void ip6_delay_external(struct delay *delay)$/;"	f
ip6_delay_internal	honeyd.c	/^void ip6_delay_internal(struct delay *delay)$/;"	f
ip6_deliver_packet_to_local_neighbor	honeyd.c	/^void ip6_deliver_packet_to_local_neighbor(const struct interface *inter,struct ip6_hdr *ip6,$/;"	f
ip6_deliver_packet_to_router	honeyd.c	/^void ip6_deliver_packet_to_router(const struct interface *inter, struct ip6_hdr *ip6,struct addr *source_mac_addr)$/;"	f
ip6_fragment	ip6frag.c	/^int ip6_fragment(struct template *tmpl, struct ip6_hdr **pip6,$/;"	f
ip6_fragment_find	ip6frag.c	/^struct fragment6* ip6_fragment_find(struct addr *src_addr,$/;"	f
ip6_fragment_init	ip6frag.c	/^void ip6_fragment_init(void)$/;"	f
ip6_fragment_new	ip6frag.c	/^struct fragment6* ip6_fragment_new(struct addr *src_addr, struct addr *dst_addr,$/;"	f
ip6_id	ip6frag.h	/^	uint32_t ip6_id;$/;"	m	struct:fragment6
ip6_insert_fragment	ip6frag.c	/^int ip6_insert_fragment(struct fragment6 *fragment, uint16_t off,$/;"	f
ip6_send_fragments	honeyd.c	/^void ip6_send_fragments(const struct interface *inter, struct addr *src_mac_addr,$/;"	f
ip6_set_more_fragments_bit	honeyd.c	/^void ip6_set_more_fragments_bit(u_int current_fragment_number,$/;"	f
ip_dst	honeyd.h	/^	ip_addr_t ip_dst;$/;"	m	struct:tuple
ip_dst	ipfrag.h	/^	ip_addr_t ip_dst;	\/* Network order *\/$/;"	m	struct:fragment
ip_fragent_free	ipfrag.c	/^ip_fragent_free(struct fragent *ent)$/;"	f
ip_fragment	ipfrag.c	/^ip_fragment(struct template *tmpl, struct ip_hdr *ip, u_short len,$/;"	f
ip_fragment_find	ipfrag.c	/^ip_fragment_find(ip_addr_t src, ip_addr_t dst, u_short id, u_char proto)$/;"	f
ip_fragment_free	ipfrag.c	/^ip_fragment_free(struct fragment *tmp)$/;"	f
ip_fragment_init	ipfrag.c	/^ip_fragment_init(void)$/;"	f
ip_fragment_insert	ipfrag.c	/^ip_fragment_insert(struct fragment *fragq, struct fragent *ent, short mf)$/;"	f
ip_fragment_new	ipfrag.c	/^ip_fragment_new(ip_addr_t src, ip_addr_t dst, u_short id, u_char proto,$/;"	f
ip_fragment_reclaim	ipfrag.c	/^ip_fragment_reclaim(int count)$/;"	f
ip_fragment_timeout	ipfrag.c	/^ip_fragment_timeout(int fd, short which, void *arg)$/;"	f
ip_id	ipfrag.h	/^	u_short ip_id;		\/* Network order *\/$/;"	m	struct:fragment
ip_personality	personality.c	/^ip_personality(struct template *tmpl, uint16_t *pid)$/;"	f
ip_proto	ipfrag.h	/^	u_char ip_proto;$/;"	m	struct:fragment
ip_send_fragments	ipfrag.c	/^ip_send_fragments(u_int mtu, struct ip_hdr *ip, u_int iplen, struct spoof spoof)$/;"	f
ip_src	honeyd.h	/^	ip_addr_t ip_src;$/;"	m	struct:tuple
ip_src	ipfrag.h	/^	ip_addr_t ip_src;	\/* Network order *\/$/;"	m	struct:fragment
ipad	stats.h	/^	u_char ipad[64];$/;"	m	struct:hmac_state
ipidtype	personality.h	/^enum ipidtype {ID_SEQUENTIAL, ID_RANDOM, ID_SEQUENTIAL_BROKEN, ID_ZERO,$/;"	g
iplen	honeyd.h	/^	u_int iplen;$/;"	m	struct:delay
is_address_managed_by_honeyd	icmp6.c	/^int is_address_managed_by_honeyd(struct addr *ip6_addr)$/;"	f
is_complete_payload_fragmentable	ip6frag.c	/^int is_complete_payload_fragmentable(struct ip6_hdr *ip6)$/;"	f
is_destination_options_followed_by_routing_hdr	ip6frag.c	/^int is_destination_options_followed_by_routing_hdr(uint8_t ext_hdr_id,struct ip6_ext_hdr * ext_hdr)$/;"	f
is_ext_hdr_id	honeyd.c	/^int is_ext_hdr_id(int ext_hdr_id)$/;"	f
is_ext_header_fragmentable	ip6frag.c	/^int is_ext_header_fragmentable(uint8_t nxt_ext_hdr)$/;"	f
is_first_fragment_received	ip6frag.c	/^int is_first_fragment_received(struct fragment6 *fragment)$/;"	f
is_fragment_complete	ip6frag.c	/^int is_fragment_complete(struct fragment6 *fragment)$/;"	f
is_fragmented_ipv6_packet	honeyd.c	/^int is_fragmented_ipv6_packet(struct ip6_hdr *ip6)$/;"	f
is_gap_beetween_fragments	ip6frag.c	/^int is_gap_beetween_fragments(struct fragment6 *fragment)$/;"	f
is_icmp6_checksum_correct	icmp6.c	/^int is_icmp6_checksum_correct(struct ip6_hdr *ip6, struct icmp6_hdr *icmp6)$/;"	f
is_invoking_icmp_fitting_in_mtu	icmp6.c	/^int is_invoking_icmp_fitting_in_mtu(int invoking_pkt_len)$/;"	f
is_ip6_addr_in_our_network	honeyd.c	/^int is_ip6_addr_in_our_network(struct addr *ip6_addr)$/;"	f
is_last_fragment_received	ip6frag.c	/^int is_last_fragment_received(struct fragment6 *fragment)$/;"	f
is_member_of_multicast_group	icmp6.c	/^int is_member_of_multicast_group(struct addr_entry *entry, struct multicast_group *group)$/;"	f
is_multicast_group_registered	icmp6.c	/^int is_multicast_group_registered(struct multicast_group *group)$/;"	f
is_no_fragments_received	ip6frag.c	/^int is_no_fragments_received(struct fragment6 *fragment)$/;"	f
is_randomly_accepted	randomipv6.c	/^int is_randomly_accepted(float randomipv6_percentage)$/;"	f
isactive	stats.h	/^	uint8_t isactive:1,$/;"	m	struct:stats
isblank	acconfig.h	54;"	d
isblank	config.h	56;"	d
kc_compare	keycount.c	/^kc_compare(const struct keycount *a, const struct keycount *b)$/;"	f
key	analyze.h	/^	void *key;$/;"	m	struct:report
key	keycount.h	/^	const void *key;$/;"	m	struct:keycount
key	keycount.h	/^	void *key;$/;"	m	struct:timekey
key	pydataprocessing.h	/^	u_char *key;$/;"	m	struct:MergedKeyValue
key	util.h	/^	char *key;$/;"	m	struct:keyvalue
key_compare	keycount.c	/^key_compare(const void *a, size_t alen, const void *b, size_t blen)$/;"	f
keycount	keycount.h	/^struct keycount$/;"	s
keycount_free	keycount.c	/^keycount_free(struct keycount *kc)$/;"	f
keycount_new	keycount.c	/^keycount_new(const void *key, size_t len,$/;"	f
keylen	analyze.h	/^	size_t keylen;$/;"	m	struct:report
keylen	keycount.h	/^	size_t keylen;$/;"	m	struct:keycount
keylen	keycount.h	/^	size_t keylen;$/;"	m	struct:timekey
keylen	pydataprocessing.h	/^	size_t keylen;$/;"	m	struct:MergedKeyValue
keyvalue	util.h	/^struct keyvalue {$/;"	s
kv_add	util.c	/^kv_add(struct keyvalueq *head, char *key, char *value)$/;"	f
kv_find	util.c	/^kv_find(struct keyvalueq *head, char *key)$/;"	f
kv_remove	util.c	/^kv_remove(struct keyvalueq *head, char *key)$/;"	f
kv_replace	util.c	/^kv_replace(struct keyvalueq *head, char *key, char *value)$/;"	f
l	sha1.c	/^	u_int l[16];$/;"	m	union:__anon1	file:
last_acked	honeyd.h	/^	uint32_t last_acked;$/;"	m	struct:tcp_con
latency	router.h	/^	int latency;$/;"	m	struct:link_entry
left	network.h	/^	struct network *left;$/;"	m	struct:network	typeref:struct:network::network
len	honeyd.h	/^	size_t len;$/;"	m	struct:conbuffer
len	hsniff.h	/^	size_t len;$/;"	m	struct:tcp_segment
len	ip6frag.h	/^	uint16_t len;$/;"	m	struct:frag6ent
len	ipfrag.h	/^	u_short len;$/;"	m	struct:fragent
len	subsystem.h	/^	socklen_t len;$/;"	m	struct:subsystem_command
limit	analyze.c	/^	int limit;$/;"	m	struct:aux	file:
line	util.c	/^	char *line;$/;"	m	struct:trace	file:
lineno	parse.c	/^int lineno;$/;"	v
linenos	lex.c	/^int linenos[MAX_INCLUDE_DEPTH];$/;"	v
link	router.h	/^	struct link_entry *link;$/;"	m	struct:router_entry	typeref:struct:router_entry::link_entry
link_drop	router.h	/^struct link_drop {$/;"	s
link_entry	router.h	/^struct link_entry {$/;"	s
link_entry_find	router.c	/^link_entry_find(struct linktree *root, struct addr *dst)$/;"	f
link_entry_new	router.c	/^link_entry_new(struct addr *dst)$/;"	f
linkcompare	router.c	/^int linkcompare(struct link_entry *a, struct link_entry *b)$/;"	f
links	router.h	/^	SPLAY_HEAD(linktree, link_entry) links;$/;"	m	struct:router
list	ethernet.c	/^	struct ethernetcode **list;$/;"	m	struct:etherindex	typeref:struct:etherindex::ethernetcode	file:
list	osfp.h	/^	struct pf_osfp_enlist *list;$/;"	m	struct:osfp	typeref:struct:osfp::pf_osfp_enlist
list_mem	ethernet.c	/^	size_t list_mem;$/;"	m	struct:etherindex	file:
list_size	ethernet.c	/^	size_t list_size;$/;"	m	struct:etherindex	file:
listen	honeyd_overload.c	/^int listen(int s, int backlog)$/;"	f
local	honeyd.h	/^	int local; \/* locally initiated *\/$/;"	m	struct:tuple
local_map	pydataprocessing.h	/^	struct PyFilter *local_map;$/;"	m	struct:PyMapFunction	typeref:struct:PyMapFunction::PyFilter
local_reduce	pydataprocessing.h	/^	struct PyFilter *local_reduce;$/;"	m	struct:PyMapFunction	typeref:struct:PyMapFunction::PyFilter
logfile	honeyd.c	/^static char *logfile = NULL; \/* Log file names *\/$/;"	v	file:
long_help	ui.c	/^	char *long_help;$/;"	m	struct:command	file:
longhash1	analyze.c	/^static __inline uint64_t longhash1(uint64_t key)$/;"	f	file:
longvalue	parse.c	/^	unsigned long long longvalue;$/;"	m	union:YYSTYPE	file:
longvalue	parse.h	/^	unsigned long long longvalue;$/;"	m	union:YYSTYPE
lookup_name_list	pfctl_osfp.c	/^lookup_name_list(struct name_list *list, const char *name)$/;"	f
low	router.h	/^	int low;$/;"	m	struct:link_drop
lsa	honeyd_overload.c	/^	struct sockaddr_storage lsa; \/* address we are representing *\/$/;"	m	struct:fd	typeref:struct:fd::sockaddr_storage	file:
lsalen	honeyd_overload.c	/^	socklen_t lsalen;$/;"	m	struct:fd	file:
magic_fd	honeyd_overload.c	/^static int magic_fd;$/;"	v	file:
main	honeyd.c	/^int main(int argc, char *argv[])$/;"	f
main	honeydctl.c	/^main(int argc, char **argv)$/;"	f
main	honeydstats_main.c	/^int main(int argc, char *argv[])$/;"	f
main	hsniff.c	/^int main(int argc, char *argv[])$/;"	f
make_bound_connect	util.c	/^make_bound_connect(int type, char *address, uint16_t port, char *local_address)$/;"	f
make_prompt	ui.c	/^make_prompt(void)$/;"	f
make_report	analyze.c	/^void make_report(struct kctree *kctree, char *filename,$/;"	f
make_socket	util.c	/^make_socket(int (*f)(int, const struct sockaddr *, socklen_t), int type,$/;"	f
make_socket_ai	util.c	/^make_socket_ai(int (*f)(int, const struct sockaddr *, socklen_t), int type,$/;"	f
match	condition.h	/^	int (*match)(const struct template *, const struct ip_hdr *, u_short,$/;"	m	struct:condition
match_arg	condition.h	/^	void *match_arg;$/;"	m	struct:condition
match_arglen	condition.h	/^	size_t match_arglen;$/;"	m	struct:condition
max_nofiles	template.h	/^	int max_nofiles;$/;"	m	struct:__anon9
max_random_ipv6_hosts	honeyd.h	/^	unsigned long long max_random_ipv6_hosts;$/;"	m	struct:config
maxlen	ipfrag.h	/^	u_short maxlen;		$/;"	m	struct:fragment
measurement	stats.c	/^	struct measurement measurement;$/;"	m	struct:statscontrol	typeref:struct:statscontrol::measurement	file:
measurement	stats.h	/^struct measurement {$/;"	s
measurement_marshal	stats.c	/^measurement_marshal(struct evbuffer *evbuf, struct measurement *m)$/;"	f
measurement_process	honeydstats.c	/^int measurement_process(struct honeyuser *user, struct evbuffer *evbuf)$/;"	f
measurement_tags	stats.h	/^} measurement_tags;$/;"	v	typeref:enum:__anon5
mid	network.h	/^	struct network *mid;$/;"	m	struct:network	typeref:struct:network::network
minute	analyze.h	/^	uint32_t minute;$/;"	m	struct:report
minutes	histogram.h	/^	struct entryq minutes;$/;"	m	struct:count	typeref:struct:count::entryq
mkv_compare	pydataprocessing.c	/^mkv_compare(struct MergedKeyValue *a, struct MergedKeyValue *b)$/;"	f
mkvs	pydataprocessing.h	/^	struct mkvtree mkvs;$/;"	m	struct:PyMapFunction	typeref:struct:PyMapFunction::mkvtree
mss	honeyd.h	/^	u_short mss;$/;"	m	struct:tcp_con
multicast_addr	icmp6.h	/^	struct addr multicast_addr;$/;"	m	struct:multicast_group	typeref:struct:multicast_group::addr
multicast_group	icmp6.h	/^struct multicast_group{$/;"	s
multicast_group_compare	icmp6.c	/^static int multicast_group_compare(struct multicast_group *a,$/;"	f	file:
multicast_group_new	icmp6.c	/^int multicast_group_new(struct addr *multicast_addr)$/;"	f
multicast_init	icmp6.c	/^void multicast_init(void)$/;"	f
nR0	sha1.c	69;"	d	file:
nR1	sha1.c	70;"	d	file:
nR2	sha1.c	71;"	d	file:
nR3	sha1.c	72;"	d	file:
nR4	sha1.c	73;"	d	file:
nalloc	pool.h	/^	int nalloc;$/;"	m	struct:pool
name	honeyd.c	/^    char *name;$/;"	m	struct:_unittest	file:
name	honeydstats.h	/^	const char *name;$/;"	m	struct:honeyuser
name	honeydstats_main.c	/^	char *name;$/;"	m	struct:_unittest	file:
name	keycount.h	/^	char *name;$/;"	m	struct:timeseries
name	personality.h	/^	char *name;$/;"	m	struct:personality
name	plugins.h	/^	const char *name;$/;"	m	struct:honeyd_plugin
name	pyextend.c	/^	char *name;$/;"	m	struct:pyextend	file:
name	stats.h	/^	char *name;$/;"	m	struct:signature
name	template.h	/^	char *name;$/;"	m	struct:__anon9
name_entry	pfctl_osfp.c	/^struct name_entry$/;"	s	file:
name_from_addr	util.c	/^name_from_addr(struct sockaddr *sa, socklen_t salen,$/;"	f
nc	dhcpclient.h	/^	struct netconf  nc;$/;"	m	struct:dhcpclient_req	typeref:struct:dhcpclient_req::netconf
ndatasrcs	rrdtool.h	/^	int ndatasrcs;$/;"	m	struct:rrdtool_db
ndp_init	icmp6.c	/^void ndp_init(void)$/;"	f
ndp_neighbor_delete	icmp6.c	/^struct ndp_neighbor_req * ndp_neighbor_delete(struct addr * target_ip_addr)$/;"	f
ndp_neighbor_find	icmp6.c	/^ndp_neighbor_find(struct addr * target_ip_addr)$/;"	f
ndp_neighbor_new	icmp6.c	/^ndp_neighbor_new(const struct interface *inter, struct addr * source_mac_addr,$/;"	f
ndp_neighbor_req	icmp6.h	/^struct ndp_neighbor_req{$/;"	s
ndp_req_compare	icmp6.c	/^static int ndp_req_compare(struct ndp_neighbor_req *a,$/;"	f	file:
need_arp	arp.c	/^int need_arp = 0; \/* We set this if we need to listen to arp traffic *\/$/;"	v
need_dhcp	dhcpclient.c	/^int need_dhcp = 0; \/* set to one if a configuration specifies dhcp *\/$/;"	v
needelete	stats.h	/^		needelete:1,$/;"	m	struct:stats
nentries	keycount.h	/^	int nentries;$/;"	m	struct:timeentry
net	network.h	/^	struct addr	net;$/;"	m	struct:network	typeref:struct:network::addr
net	router.h	/^	struct addr net;$/;"	m	struct:router_entry	typeref:struct:router_entry::addr
net_order	network.h	/^enum net_order$/;"	g
netconf	dhcpclient.h	/^struct netconf {$/;"	s
netconf_mknetmask	dhcpclient.c	/^static void netconf_mknetmask(struct addr *ipaddr, struct addr *ipmask)$/;"	f	file:
network	network.h	/^struct network {$/;"	s
network	router.h	/^	struct addr network;		\/* Responsible (entry router only) *\/$/;"	m	struct:router	typeref:struct:router::addr
network_add	router.c	/^void network_add(struct network **root, struct addr *addr, void *data)$/;"	f
network_addnode	router.c	/^static void network_addnode(struct network **root, struct network *new,$/;"	f	file:
network_balancetree	router.c	/^static void network_balancetree(struct network **cur)$/;"	f	file:
network_calcd	router.c	/^static void network_calcd(struct network *net)$/;"	f	file:
network_cleanup	router.c	/^void network_cleanup(struct network *net, int needfree)$/;"	f
network_compare	network.c	/^network_compare(struct network *a, struct network *b)$/;"	f
network_compare6	network.c	/^enum net_order network_compare6(struct network *a, struct network *b){$/;"	f
network_copydata	router.c	/^static void network_copydata(struct network *dst, struct network *src)$/;"	f	file:
network_lookup	router.c	/^network_lookup(struct network *root, struct addr *addr)$/;"	f
network_test	network.c	/^network_test(void)$/;"	f
network_test_compare	network.c	/^network_test_compare(void)$/;"	f	file:
network_test_compare6	network.c	/^network_test_compare6(void){$/;"	f	file:
network_walkadd	router.c	/^static void network_walkadd(struct network **root, struct network *net,$/;"	f	file:
new_dst	honeyd.h	/^	struct addr new_dst; \/* where the reply should go *\/$/;"	m	struct:spoof	typeref:struct:spoof::addr
new_fd	honeyd_overload.c	/^new_fd(int fd)$/;"	f	file:
new_src	honeyd.h	/^	struct addr new_src; \/* where the reply should appear to come from *\/$/;"	m	struct:spoof	typeref:struct:spoof::addr
newsock_fd	honeyd_overload.c	/^newsock_fd(int domain, int type, int protocol)$/;"	f	file:
next	analyze.h	/^	TAILQ_ENTRY(auxkey) next;$/;"	m	struct:auxkey
next	condition.h	/^	TAILQ_ENTRY(condition) next;$/;"	m	struct:condition
next	histogram.h	/^	TAILQ_ENTRY(entry) next;$/;"	m	struct:entry
next	honeyd.h	/^	TAILQ_ENTRY(conbuffer) next;$/;"	m	struct:conbuffer
next	honeyd.h	/^	TAILQ_ENTRY(port) next;$/;"	m	struct:port
next	honeyd.h	/^	TAILQ_ENTRY(port_encapsulate) next;$/;"	m	struct:port_encapsulate
next	honeyd.h	/^	TAILQ_ENTRY(tuple) next;$/;"	m	struct:tuple
next	hsniff.h	/^	TAILQ_ENTRY(tcp_segment) next;$/;"	m	struct:tcp_segment
next	icmp6.h	/^	SPLAY_ENTRY(addr_entry) next;$/;"	m	struct:addr_entry
next	icmp6.h	/^	SPLAY_ENTRY(multicast_group) next;$/;"	m	struct:multicast_group
next	icmp6.h	/^	SPLAY_ENTRY(ndp_neighbor_req) next;$/;"	m	struct:ndp_neighbor_req
next	interface.h	/^	TAILQ_ENTRY(interface) next;$/;"	m	struct:interface
next	ip6frag.h	/^	TAILQ_ENTRY(frag6ent) next;$/;"	m	struct:frag6ent
next	ip6frag.h	/^	TAILQ_ENTRY(fragment6) next;$/;"	m	struct:fragment6
next	ipfrag.h	/^	TAILQ_ENTRY(fragent) next;$/;"	m	struct:fragent
next	ipfrag.h	/^	TAILQ_ENTRY(fragment) next;$/;"	m	struct:fragment
next	keycount.h	/^	TAILQ_ENTRY(timeentry) next;$/;"	m	struct:timeentry
next	pool.h	/^	SLIST_ENTRY(pool_entry) next;$/;"	m	struct:pool_entry
next	pydataprocessing.h	/^	TAILQ_ENTRY(PyMapFunction) next;$/;"	m	struct:PyMapFunction
next	pydataprocessing.h	/^	TAILQ_ENTRY(SingleValue) next;$/;"	m	struct:SingleValue
next	rrdtool.h	/^	TAILQ_ENTRY(rrdtool_command) next;$/;"	m	struct:rrdtool_command
next	stats.h	/^	TAILQ_ENTRY(stats) next;$/;"	m	struct:stats
next	stats.h	/^	TAILQ_ENTRY(stats_packet) next;$/;"	m	struct:stats_packet
next	subsystem.h	/^	TAILQ_ENTRY(subsystem) next;$/;"	m	struct:subsystem
next	subsystem.h	/^	TAILQ_ENTRY(template_container) next;$/;"	m	struct:template_container
next	tagging.h	/^	TAILQ_ENTRY(hash) next;$/;"	m	struct:hash
next	template.h	/^	TAILQ_ENTRY(subsystem_container) next;$/;"	m	struct:subsystem_container
next	util.h	/^	TAILQ_ENTRY(keyvalue) next;$/;"	m	struct:keyvalue
next_ha	arp.h	/^	SPLAY_ENTRY(arp_req)	next_ha;$/;"	m	struct:arp_req
next_pa	arp.h	/^	SPLAY_ENTRY(arp_req)	next_pa;$/;"	m	struct:arp_req
next_rejected_ipv6_addr	randomipv6.h	/^	RB_ENTRY(rejected_ipv6_addr) next_rejected_ipv6_addr;$/;"	m	struct:rejected_ipv6_addr
nfragmem	ipfrag.c	/^int nfragmem;$/;"	v
nfragments	ipfrag.c	/^int nfragments;$/;"	v
nfuncs	bloom.h	/^  size_t nfuncs;$/;"	m	struct:__anon2
nincoming	honeyd.h	/^	int nincoming;$/;"	m	struct:udp_con
nm_name	pfctl_osfp.c	/^	char nm_name[PF_OSFP_LEN];$/;"	m	struct:name_entry	file:
nm_num	pfctl_osfp.c	/^	int nm_num;$/;"	m	struct:name_entry	file:
nm_sublist	pfctl_osfp.c	/^	struct name_list nm_sublist;$/;"	m	struct:name_entry	typeref:struct:name_entry::name_list	file:
nm_sublist_num	pfctl_osfp.c	/^	int nm_sublist_num;$/;"	m	struct:name_entry	file:
nmap_name	xprobe_assoc.h	/^	char                    *nmap_name;$/;"	m	struct:assoc_item
no_spoof	honeyd.c	/^struct spoof no_spoof; \/* spoof settings for default packet processing *\/$/;"	v	typeref:struct:spoof
noarg	getopt_long.c	/^static const char noarg[] = "option doesn't take an argument -- %.*s";$/;"	v	file:
node	analyze.h	/^	SPLAY_ENTRY(auxkey) node;$/;"	m	struct:auxkey
node	analyze.h	/^	SPLAY_ENTRY(report) node;$/;"	m	struct:report
node	filter.h	/^	SPLAY_ENTRY(filter) node;$/;"	m	struct:filter
node	honeyd.h	/^	SPLAY_ENTRY(port) node;$/;"	m	struct:port
node	honeyd.h	/^	SPLAY_ENTRY(tuple) node;$/;"	m	struct:tuple
node	honeydstats.h	/^	SPLAY_ENTRY(honeyuser) node;$/;"	m	struct:honeyuser
node	ip6frag.h	/^	SPLAY_ENTRY(fragment6) node;$/;"	m	struct:fragment6
node	ipfrag.h	/^	SPLAY_ENTRY(fragment) node;$/;"	m	struct:fragment
node	keycount.h	/^	SPLAY_ENTRY(keycount) node;$/;"	m	struct:keycount
node	keycount.h	/^	SPLAY_ENTRY(timekey) node;$/;"	m	struct:timekey
node	keycount.h	/^	SPLAY_ENTRY(timeseries) node;$/;"	m	struct:timeseries
node	osfp.h	/^	SPLAY_ENTRY(osfp) node;$/;"	m	struct:osfp
node	personality.h	/^	SPLAY_ENTRY(personality) node;$/;"	m	struct:personality
node	personality.h	/^	SPLAY_ENTRY(xp_fingerprint) node;$/;"	m	struct:xp_fingerprint
node	pydataprocessing.h	/^	SPLAY_ENTRY(MergedKeyValue) node;$/;"	m	struct:MergedKeyValue
node	router.h	/^	SPLAY_ENTRY(link_entry) node;$/;"	m	struct:link_entry
node	router.h	/^	SPLAY_ENTRY(router) node;$/;"	m	struct:router
node	router.h	/^	SPLAY_ENTRY(router_entry) node;$/;"	m	struct:router_entry
node	stats.h	/^	SPLAY_ENTRY(stats) node;$/;"	m	struct:stats
node	subsystem.h	/^	SPLAY_ENTRY(template_container) node;$/;"	m	struct:template_container
node	template.h	/^	SPLAY_ENTRY(template) node;$/;"	m	struct:__anon9
node	xprobe_assoc.h	/^	SPLAY_ENTRY(assoc_item) node;$/;"	m	struct:assoc_item
nonopt_end	getopt_long.c	/^static int nonopt_end = -1;   \/* first option after non options (for permute) *\/$/;"	v	file:
nonopt_start	getopt_long.c	/^static int nonopt_start = -1; \/* first non option argument (for permute) *\/$/;"	v	file:
npersons	personality.c	/^int npersons;$/;"	v
nreports	honeydstats.h	/^	int nreports;		\/* how many reports we have received *\/$/;"	m	struct:honeyuser
nsaddr	dhcpclient.h	/^	struct addr nsaddr[4];$/;"	m	struct:netconf	typeref:struct:netconf::addr
ntries	dhcpclient.h	/^	int             ntries;$/;"	m	struct:dhcpclient_req
num_values	pydataprocessing.h	/^	int num_values;$/;"	m	struct:MergedKeyValue
number	honeyd.h	/^	u_short number;$/;"	m	struct:port
number	parse.c	/^	int number;$/;"	m	union:YYSTYPE	file:
number	parse.h	/^	int number;$/;"	m	union:YYSTYPE
number_of_collisions	randomipv6.c	/^int number_of_collisions = 0;$/;"	v
number_of_fingerprints	FPModelConverted.h	/^int number_of_fingerprints = 65;$/;"	v
nxt_hdr	ip6frag.h	/^	uint8_t nxt_hdr;$/;"	m	struct:fragment6
octx	stats.h	/^	SHA1_CTX octx;$/;"	m	struct:hmac_state
off	ip6frag.h	/^	uint16_t off;$/;"	m	struct:frag6ent
off	ipfrag.h	/^	u_short off;$/;"	m	struct:fragent
offset	personality.c	/^	int offset;$/;"	m	struct:parse_test	file:
offset	pyextend.c	/^	int offset;$/;"	m	struct:pyextend_count	file:
opad	stats.h	/^	u_char opad[64];$/;"	m	struct:hmac_state
optarg	getopt_long.c	/^char    *optarg;		\/* argument associated with option *\/$/;"	v
opterr	getopt_long.c	/^int	opterr = 1;		\/* if error message should be printed *\/$/;"	v
optind	getopt_long.c	/^int	optind = 1;		\/* index into parent argv vector *\/$/;"	v
option	plugins_config.c	/^	char                       *option;$/;"	m	struct:honeyd_plugin_cfgitem	file:
options	personality.h	/^	char *options;$/;"	m	struct:personate
optopt	getopt_long.c	/^int	optopt = '?';		\/* character checked for validity *\/$/;"	v
optreset	getopt_long.c	/^int	optreset;		\/* reset getopt *\/$/;"	v
os_fp	tagging.h	/^	char *os_fp; \/* optional *\/$/;"	m	struct:record
os_id	personality.h	/^	char                 *os_id;   \/\/OS name$/;"	m	struct:xp_fingerprint
os_key_extract	analyze.c	/^void os_key_extract(struct keycount *keycount, void **pkey, size_t *pkeylen)$/;"	f
os_key_print	analyze.c	/^os_key_print(void *key, size_t keylen)$/;"	f
os_names	FPModelConverted.h	/^char *os_names[] = {$/;"	v
os_report_file	analyze.c	/^char *os_report_file = NULL;$/;"	v
os_test	analyze.c	/^void os_test()$/;"	f
oses	analyze.c	/^struct kctree oses;$/;"	v	typeref:struct:kctree
osfp	honeyd.h	/^	char *osfp;$/;"	m	struct:config
osfp	osfp.h	/^struct osfp {$/;"	s
osfp_compare	osfp.c	/^int osfp_compare(struct osfp *a, struct osfp *b)$/;"	f
outbuf	ui.h	/^	struct evbuffer *outbuf;$/;"	m	struct:uiclient	typeref:struct:uiclient::evbuffer
output_bytes	honeyd.h	/^	struct count *output_bytes;$/;"	m	struct:stats_network	typeref:struct:stats_network::count
owner	arp.h	/^	struct template	       *owner;	\/* template this req refers to *\/$/;"	m	struct:arp_req	typeref:struct:arp_req::
owner	icmp6.h	/^	struct template *owner;$/;"	m	struct:ndp_neighbor_req	typeref:struct:ndp_neighbor_req::
pArgs	pyextend.c	/^	PyObject *pArgs;$/;"	m	struct:pyextend_count	file:
pFuncEnd	pyextend.c	/^	PyObject *pFuncEnd;$/;"	m	struct:pyextend	file:
pFuncInit	pyextend.c	/^	PyObject *pFuncInit;$/;"	m	struct:pyextend	file:
pFuncReadData	pyextend.c	/^	PyObject *pFuncReadData;$/;"	m	struct:pyextend	file:
pFuncRequest	pyextend.c	/^static PyObject *pFuncRequest;	\/* handle request function *\/$/;"	v	file:
pFuncWriteData	pyextend.c	/^	PyObject *pFuncWriteData;$/;"	m	struct:pyextend	file:
pWebServer	pyextend.c	/^static PyObject *pWebServer;	\/* web server instance *\/$/;"	v	file:
pa	arp.h	/^	struct addr		pa;$/;"	m	struct:arp_req	typeref:struct:arp_req::addr
pa_compare	arp.c	/^static int pa_compare(struct arp_req *a, struct arp_req *b)$/;"	f	file:
packetloss	router.h	/^	int packetloss;		\/* percent x 100 *\/$/;"	m	struct:link_entry
parent	router.h	/^	struct router *parent;$/;"	m	struct:router_entry	typeref:struct:router_entry::router
parse_and_load_ttl_pair	personality.c	/^parse_and_load_ttl_pair(char *p)$/;"	f	file:
parse_associations	xprobe_assoc.c	/^int parse_associations(FILE *fp)$/;"	f
parse_configuration	parse.c	/^parse_configuration(FILE *input, char *name)$/;"	f
parse_line	parse.c	/^parse_line(struct evbuffer *output, char *line)$/;"	f
parse_long_options	getopt_long.c	/^parse_long_options(char * const *nargv, const char *options,$/;"	f	file:
parse_pu	personality.c	/^parse_pu(struct personality *pers, int off, char *line)$/;"	f
parse_test	personality.c	/^	int (*parse_test)(struct personality *, int, char *);$/;"	m	struct:parse_test	file:
parse_test	personality.c	/^struct parse_test {$/;"	s	file:
parse_tests	personality.c	/^parse_tests[] = {$/;"	v	typeref:struct:parse_test
parse_tl	personality.c	/^parse_tl(struct personality *pers, int off, char *line)$/;"	f
parse_tseq	personality.c	/^parse_tseq(struct personality *pers, int off, char *line)$/;"	f
parse_tseq_gcd	personality.c	/^parse_tseq_gcd(char *s, char *end)$/;"	f
parse_tseq_si	personality.c	/^parse_tseq_si(struct personality *pers, char *s, char *end)$/;"	f
passwd	honeydctl.c	/^char *passwd;$/;"	v
payload	honeyd.h	/^	u_char *payload;$/;"	m	struct:tcp_con
pcap_datalink	honeydstats.c	/^int pcap_datalink(void *some)$/;"	f
pcap_dloff	util.c	/^pcap_dloff(pcap_t *pd)$/;"	f
pending	honeyd.h	/^	pending;$/;"	m	struct:port
pending	honeyd.h	/^	struct port_encapsulate *pending;$/;"	m	struct:tuple	typeref:struct:tuple::port_encapsulate
peread	honeyd.h	/^	struct event peread;$/;"	m	struct:command	typeref:struct:command::event
permute_args	getopt_long.c	/^permute_args(int panonopt_start, int panonopt_end, int opt_end,$/;"	f	file:
perrfd	honeyd.h	/^	int perrfd;$/;"	m	struct:command
pers	honeyd.h	/^	char *pers;$/;"	m	struct:config
pers	parse.c	/^	struct personality_set *pers;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::personality_set	file:
pers	parse.h	/^	struct personality_set *pers;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::personality_set
perscompare	personality.h	/^perscompare(struct personality *a, struct personality *b)$/;"	f
person	template.h	/^	struct personality *person;$/;"	m	struct:__anon9	typeref:struct:__anon9::personality
person4	personality.h	/^	struct personality *person4;$/;"	m	struct:personality_set	typeref:struct:personality_set::personality
person6	personality.h	/^	struct personality *person6;$/;"	m	struct:personality_set	typeref:struct:personality_set::personality
person6	template.h	/^	struct personality *person6;$/;"	m	struct:__anon9	typeref:struct:__anon9::personality
person_drop	personality.c	/^struct personate person_drop = {};$/;"	v	typeref:struct:personate
personality	personality.h	/^struct personality {$/;"	s
personality_clone	personality.c	/^personality_clone(const struct personality *person)$/;"	f
personality_config_new	personality.c	/^personality_config_new(const char *name, int lineno)$/;"	f
personality_declone	personality.c	/^personality_declone(struct personality *pers)$/;"	f
personality_find	personality.c	/^personality_find(const char *name)$/;"	f
personality_find6	personality.c	/^personality_find6(const char *name)$/;"	f
personality_free	personality.c	/^personality_free(struct personality *pers)$/;"	f
personality_init	personality.c	/^personality_init(void)$/;"	f
personality_init6	personality.c	/^personality_init6(void)$/;"	f
personality_line	personality.c	/^personality_line(struct personality *pers, char *line)$/;"	f
personality_new	personality.c	/^personality_new(const char *name)$/;"	f
personality_new6	personality.c	/^personality_new6(const char *name)$/;"	f
personality_parse	personality.c	/^personality_parse(FILE *fin)$/;"	f
personality_random	personality.c	/^personality_random(void)$/;"	f
personality_set	personality.h	/^struct personality_set{$/;"	s
personality_time	personality.c	/^personality_time(struct template *tmpl, struct timeval *diff)$/;"	f
personality_time_ev	personality.c	/^static struct event personality_time_ev;$/;"	v	typeref:struct:event	file:
personality_time_evcb	personality.c	/^personality_time_evcb(int fd, short what, void *arg)$/;"	f	file:
personate	personality.h	/^struct personate {$/;"	s
persudp	personality.h	/^struct persudp {$/;"	s
pf_os_fingerprint	pfvar.h	/^struct pf_os_fingerprint {$/;"	s
pf_osfp_add	pf_osfp.c	/^pf_osfp_add(struct pf_osfp_ioctl *fpioc)$/;"	f
pf_osfp_entry	pfvar.h	/^struct pf_osfp_entry {$/;"	s
pf_osfp_entry_pl	pf_osfp.c	/^pool_t pf_osfp_entry_pl;$/;"	v
pf_osfp_find	pf_osfp.c	/^pf_osfp_find(struct pf_osfp_list *list, struct pf_os_fingerprint *find,$/;"	f
pf_osfp_find_exact	pf_osfp.c	/^pf_osfp_find_exact(struct pf_osfp_list *list, struct pf_os_fingerprint *find)$/;"	f
pf_osfp_fingerprint_hdr	pf_osfp.c	/^pf_osfp_fingerprint_hdr(const struct ip_hdr *ip, const struct tcp_hdr *tcp)$/;"	f
pf_osfp_flush	pf_osfp.c	/^pf_osfp_flush(void)$/;"	f
pf_osfp_get	pf_osfp.c	/^pf_osfp_get(struct pf_osfp_ioctl *fpioc)$/;"	f
pf_osfp_initialize	pf_osfp.c	/^pf_osfp_initialize(void)$/;"	f
pf_osfp_insert	pf_osfp.c	/^pf_osfp_insert(struct pf_osfp_list *list, struct pf_os_fingerprint *ins)$/;"	f
pf_osfp_ioctl	pfvar.h	/^struct pf_osfp_ioctl {$/;"	s
pf_osfp_match	pf_osfp.c	/^pf_osfp_match(struct pf_osfp_enlist *list, pf_osfp_t os)$/;"	f
pf_osfp_pl	pf_osfp.c	/^pool_t pf_osfp_pl;$/;"	v
pf_osfp_t	pfvar.h	/^typedef u_int32_t pf_osfp_t;$/;"	t
pf_osfp_validate	pf_osfp.c	/^pf_osfp_validate(void)$/;"	f
pf_tcpopts_t	pfvar.h	/^typedef u_int64_t	pf_tcpopts_t;$/;"	t
pfctl_file_fingerprints	pfctl_osfp.c	/^int pfctl_file_fingerprints(int dev, int opts, const char *fp_filename)$/;"	f
pfctl_get_fingerprint	pfctl_osfp.c	/^pf_osfp_t pfctl_get_fingerprint(const char *name)$/;"	f
pfctl_show_fingerprints	pfctl_osfp.c	/^void pfctl_show_fingerprints(int opts)$/;"	f
pfd	honeyd.h	/^	int pfd;$/;"	m	struct:command
pid	honeyd.h	/^	pid_t pid;$/;"	m	struct:command
pid	rrdtool.h	/^	pid_t pid;$/;"	m	struct:rrdtool_drv
pkt	gre.c	/^static u_char pkt[IP_LEN_MAX];$/;"	v	file:
place	getopt_long.c	/^static char *place = EMSG; \/* option letter processing *\/$/;"	v	file:
plen	honeyd.h	/^	u_int plen; \/* date in buffer *\/$/;"	m	struct:tcp_con
plugin	plugins_config.c	/^	char                       *plugin;$/;"	m	struct:honeyd_plugin_cfgitem	file:
plugin_dummy_init	plugins.c	/^static int plugin_dummy_init(void)$/;"	f	file:
plugin_hook_up	plugins.c	/^static void plugin_hook_up(struct honeyd_plugin *plugin)$/;"	f	file:
plugins	plugins.c	/^struct honeyd_plugin *plugins[] =$/;"	v	typeref:struct:honeyd_plugin
plugins_cfg_copy	plugins_config.c	/^plugins_cfg_copy(const struct honeyd_plugin_cfg *cfg_src,$/;"	f	file:
plugins_config_find_item	plugins_config.c	/^plugins_config_find_item(const char *plugin, const char *option,$/;"	f
plugins_config_init	plugins_config.c	/^plugins_config_init(void)$/;"	f
plugins_config_item_add	plugins_config.c	/^plugins_config_item_add(const char *plugin, const char *option,$/;"	f
plugins_find	plugins.c	/^plugins_find(const char *name)$/;"	f
plugins_init	plugins.c	/^void plugins_init(void)$/;"	f
poff	honeyd.h	/^	u_int poff; \/* current send offset *\/$/;"	m	struct:tcp_con
pool	pool.h	/^struct pool {$/;"	s
pool_alloc	pool.h	/^pool_alloc(struct pool *pool)$/;"	f
pool_alloc_size	pool.c	/^pool_alloc_size(struct pool *pool, size_t size)$/;"	f
pool_delay	honeyd.c	/^struct pool *pool_delay;$/;"	v	typeref:struct:pool
pool_entry	pool.h	/^struct pool_entry {$/;"	s
pool_free	pool.h	/^pool_free(struct pool *pool, void *addr)$/;"	f
pool_get	pf_osfp.c	42;"	d	file:
pool_init	pf_osfp.c	44;"	d	file:
pool_init	pool.c	/^pool_init(size_t size)$/;"	f
pool_network	router.c	/^static struct pool *pool_network;$/;"	v	typeref:struct:pool	file:
pool_pkt	honeyd.c	/^struct pool *pool_pkt;$/;"	v	typeref:struct:pool
pool_put	pf_osfp.c	43;"	d	file:
pool_t	pf_osfp.c	41;"	d	file:
port	honeyd.h	/^	struct port *port; \/* used if bound to sub system *\/$/;"	m	struct:tcp_con	typeref:struct:tcp_con::port
port	honeyd.h	/^	struct port *port;$/;"	m	struct:port_encapsulate	typeref:struct:port_encapsulate::port
port	honeyd.h	/^	struct port *port;$/;"	m	struct:udp_con	typeref:struct:udp_con::port
port	honeyd.h	/^struct port$/;"	s
port_action_clone	config.c	/^port_action_clone(struct action *dst, const struct action *src)$/;"	f
port_compare	config.c	/^port_compare(struct port *a, struct port *b)$/;"	f
port_encapsulate	honeyd.h	/^struct port_encapsulate$/;"	s
port_encapsulation_free	config.c	/^port_encapsulation_free(struct port_encapsulate *tmp)$/;"	f
port_find	config.c	/^port_find(struct template *tmpl, int proto, int number)$/;"	f
port_free	config.c	/^port_free(struct template *tmpl, struct port *port)$/;"	f
port_hash	analyze.c	/^static __inline uint32_t port_hash(const struct addr *src,$/;"	f	file:
port_insert	config.c	/^port_insert(struct template *tmpl, int proto, int number,$/;"	f
port_key_extract	analyze.c	/^void port_key_extract(struct keycount *keycount, void **pkey, size_t *pkeylen)$/;"	f
port_key_print	analyze.c	/^port_key_print(void *key, size_t keylen)$/;"	f
port_random	config.c	/^port_random(struct template *tmpl, int proto, struct action *action,$/;"	f
port_report_file	analyze.c	/^char *port_report_file = NULL;$/;"	v
ports	analyze.c	/^struct kctree ports;$/;"	v	typeref:struct:kctree
ports	subsystem.h	/^	ports; \/* list of configured ports *\/$/;"	m	struct:subsystem
ports	template.h	/^	struct porttree ports;$/;"	m	struct:__anon9	typeref:struct:__anon9::porttree
pppdead	honeydctl.c	/^jmp_buf pppdead;$/;"	v
pread	honeyd.h	/^	struct event pread;$/;"	m	struct:command	typeref:struct:command::event
pread	pyextend.c	/^	struct event pread;$/;"	m	struct:pystate	typeref:struct:pystate::event	file:
prefix	ethernet.c	/^	uint32_t prefix;$/;"	m	struct:ethernetcode	file:
prefix	icmp6.h	/^	struct addr prefix;$/;"	m	struct:router_advertisement	typeref:struct:router_advertisement::addr
prefix_len	icmp6.h	/^	int prefix_len;$/;"	m	struct:router_advertisement
print	keycount.h	/^	void (*print)(void *, size_t);$/;"	m	struct:timeseries
print_ioctl	pfctl_osfp.c	/^print_ioctl(struct pf_osfp_ioctl *fp)$/;"	f
print_name_list	pfctl_osfp.c	/^void print_name_list(int opts, struct name_list *nml, const char *prefix)$/;"	f
print_perstree	personality.c	/^print_perstree(void)$/;"	f
print_spoof	honeyd.c	/^void print_spoof(char *msg, struct spoof s)$/;"	f
print_xprobe_struct	personality.c	/^print_xprobe_struct(struct xp_fingerprint *pers)$/;"	f	file:
privip_counter	config.c	/^static uint16_t privip_counter = 1;$/;"	v	file:
prompt	honeydctl.c	/^char *prompt;$/;"	v
proto	honeyd.h	/^	int proto;$/;"	m	struct:port
proto	tagging.h	/^	uint8_t proto;$/;"	m	struct:record
protocol	honeyd_overload.c	/^	int protocol;$/;"	m	struct:fd	file:
protocol	subsystem.h	/^	int protocol;$/;"	m	struct:subsystem_command
proxy_connect	honeyd.c	/^int proxy_connect(struct tuple *hdr, struct command *cmd, struct addrinfo *ai,$/;"	f
psize	honeyd.h	/^	u_int psize;$/;"	m	struct:tcp_con
pwrite	honeyd.h	/^	struct event pwrite;$/;"	m	struct:command	typeref:struct:command::event
pwrite	pyextend.c	/^	struct event pwrite;$/;"	m	struct:pystate	typeref:struct:pystate::event	file:
pydatahoneyd_test	pydatahoneyd.c	/^pydatahoneyd_test(void)$/;"	f
pydataprocessing_init	pydataprocessing.c	/^pydataprocessing_init(void)$/;"	f
pydataprocessing_test	pydataprocessing.c	/^pydataprocessing_test(void)$/;"	f
pye	pyextend.c	/^	struct pyextend *pye;$/;"	m	struct:pystate	typeref:struct:pystate::pyextend	file:
pye_compare	pyextend.c	/^pye_compare(struct pyextend *a, struct pyextend *b)$/;"	f
pyextend	pyextend.c	/^struct pyextend {$/;"	s	file:
pyextend_accept	pyextend.c	/^pyextend_accept(int fd, short what, void *arg)$/;"	f
pyextend_addbuffer	pyextend.c	/^pyextend_addbuffer(struct pystate *state, u_char *buf, size_t size)$/;"	f	file:
pyextend_cbread	pyextend.c	/^pyextend_cbread(int fd, short what, void *arg)$/;"	f	file:
pyextend_cbwrite	pyextend.c	/^pyextend_cbwrite(int fd, short what, void *arg)$/;"	f	file:
pyextend_config	pyextend.c	/^pyextend_config(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_config_ips	pyextend.c	/^pyextend_config_ips(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_connection_end	pyextend.c	/^pyextend_connection_end(struct pystate *state)$/;"	f
pyextend_connection_start	pyextend.c	/^pyextend_connection_start(struct tuple *hdr, struct command *cmd,$/;"	f
pyextend_count	pyextend.c	/^struct pyextend_count {$/;"	s	file:
pyextend_count_ips	pyextend.c	/^pyextend_count_ips(struct template *tmpl, void *arg)$/;"	f
pyextend_delete_connection	pyextend.c	/^pyextend_delete_connection(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_delete_template	pyextend.c	/^pyextend_delete_template(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_dict_global	pyextend.c	/^PyObject *pyextend_dict_global;$/;"	v
pyextend_dict_local	pyextend.c	/^PyObject *pyextend_dict_local;$/;"	v
pyextend_evb_errcb	pyextend.c	/^pyextend_evb_errcb(struct bufferevent *bev, short what, void *parameter)$/;"	f
pyextend_evb_readcb	pyextend.c	/^pyextend_evb_readcb(struct bufferevent *bev, void *parameter)$/;"	f
pyextend_evb_writecb	pyextend.c	/^pyextend_evb_writecb(struct bufferevent *bev, void *parameter)$/;"	f
pyextend_exit	pyextend.c	/^pyextend_exit(void)$/;"	f
pyextend_freestate	pyextend.c	/^pyextend_freestate(struct pystate *state)$/;"	f	file:
pyextend_humanreadable_action	pyextend.c	/^pyextend_humanreadable_action(struct action *action, char *buffer, size_t len)$/;"	f
pyextend_init	pyextend.c	/^pyextend_init(void)$/;"	f
pyextend_interfaces	pyextend.c	/^pyextend_interfaces(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_is_ipaddress	pyextend.c	/^pyextend_is_ipaddress(struct template *tmpl)$/;"	f
pyextend_load_module	pyextend.c	/^pyextend_load_module(const char *name)$/;"	f
pyextend_log	pyextend.c	/^pyextend_log(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_newstate	pyextend.c	/^pyextend_newstate(struct command *cmd, void *con, struct pyextend *pye)$/;"	f	file:
pyextend_populate_connections	pyextend.c	/^pyextend_populate_connections(struct tuple *hdr, void *arg)$/;"	f	file:
pyextend_populate_ips	pyextend.c	/^pyextend_populate_ips(struct template *tmpl, void *arg)$/;"	f
pyextend_raw_log	pyextend.c	/^pyextend_raw_log(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_readselector	pyextend.c	/^pyextend_readselector(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_request	pyextend.h	/^struct pyextend_request {$/;"	s
pyextend_request_free	pyextend.c	/^pyextend_request_free(struct pyextend_request *req)$/;"	f
pyextend_request_new	pyextend.c	/^pyextend_request_new(int fd, struct addr *src)$/;"	f
pyextend_run	pyextend.c	/^pyextend_run(struct evbuffer *output, char *command)$/;"	f
pyextend_security_info	pyextend.c	/^pyextend_security_info(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_selector	pyextend.c	/^pyextend_selector(PyObject *args, struct event *ev, const char *name)$/;"	f	file:
pyextend_stats_network	pyextend.c	/^pyextend_stats_network(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_status_connections	pyextend.c	/^pyextend_status_connections(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_uptime	pyextend.c	/^pyextend_uptime(PyObject *self, PyObject *args)$/;"	f	file:
pyextend_webserver_exit	pyextend.c	/^pyextend_webserver_exit(void)$/;"	f
pyextend_webserver_fix_permissions	pyextend.c	/^pyextend_webserver_fix_permissions(const char *path, uid_t uid, gid_t gid)$/;"	f
pyextend_webserver_init	pyextend.c	/^pyextend_webserver_init(char *address, int port, char *root_dir)$/;"	f
pyextend_webserver_verify_setup	pyextend.c	/^pyextend_webserver_verify_setup(const char *root_dir)$/;"	f
pyextend_writeselector	pyextend.c	/^pyextend_writeselector(PyObject *self, PyObject *args)$/;"	f	file:
pyfilter_test	pydataprocessing.c	/^pyfilter_test(void)$/;"	f
pyrecord_test	pydatahoneyd.c	/^pyrecord_test(void)$/;"	f
pyserver_fd	pyextend.c	/^static int pyserver_fd = -1;$/;"	v	file:
pystate	pyextend.c	/^struct pystate {$/;"	s	file:
pywrite	pyextend.c	/^struct pywrite {$/;"	s	file:
quotelen	personality.h	/^	int quotelen;$/;"	m	struct:persudp
random_create_ipv6_template	randomipv6.c	/^void random_create_ipv6_template(char *template_name, const struct interface *inter,float randomipv6_percentage,unsigned long long max_random_ipv6_hosts, FILE *logfp)$/;"	f
randomipv6_init	randomipv6.c	/^void randomipv6_init()$/;"	f
randomipv6_percentage	honeyd.h	/^	float randomipv6_percentage;$/;"	m	struct:config
randomipv6mode	honeyd.h	/^	int randomipv6mode; \/* random mode enabled or not *\/$/;"	m	struct:config
rcsid	daemon.c	/^static char rcsid[] = "$OpenBSD: daemon.c,v 1.4 1995\/02\/25 13:41:16 cgd Exp $";$/;"	v	file:
rcsid	sha1.c	/^static char rcsid[] = "$OpenBSD: sha1.c,v 1.12 2003\/07\/21 20:37:08 millert Exp $";$/;"	v	file:
rcsid	strlcat.c	/^static char *rcsid = "$OpenBSD: strlcat.c,v 1.8 2001\/05\/13 15:40:15 deraadt Exp $";$/;"	v	file:
rcsid	strlcpy.c	/^static char *rcsid = "$OpenBSD: strlcpy.c,v 1.2 1998\/11\/06 04:33:16 wvdputte Exp $";$/;"	v	file:
rcv_flags	honeyd.h	/^	uint8_t rcv_flags;$/;"	m	struct:tcp_con
rcv_next	honeyd.h	/^	uint32_t rcv_next;$/;"	m	struct:tcp_con
read_cb	honeydstats_main.c	/^static void read_cb(int fd, short what, void *arg)$/;"	f	file:
readbuf	honeyd.h	/^	u_char *readbuf;$/;"	m	struct:tcp_con
recargchar	getopt_long.c	/^static const char recargchar[] = "option requires an argument -- %c";$/;"	v	file:
recargstring	getopt_long.c	/^static const char recargstring[] = "option requires an argument -- %s";$/;"	v	file:
receive	honeydctl.c	/^receive(int fd, int display)$/;"	f
receive_fd	fdpass.c	/^int receive_fd(int socket, void *base, size_t *len)$/;"	f
received	honeyd.h	/^	uint32_t received;$/;"	m	struct:tuple
record	stats.h	/^	struct record record;$/;"	m	struct:stats	typeref:struct:stats::record
record	tagging.h	/^struct record$/;"	s
record_add_hash	stats.c	/^record_add_hash(struct hashq *hashes, void *data, size_t len)$/;"	f
record_clean	stats.c	/^record_clean(struct record *record)$/;"	f
record_data	pydatahoneyd.c	/^static unsigned char record_data[] = {$/;"	v	file:
record_fill	stats.c	/^record_fill(struct record *r, const struct tuple *hdr)$/;"	f
record_marshal	tagging.c	/^record_marshal(struct evbuffer *evbuf, struct record *record)$/;"	f
record_process	honeydstats.c	/^int record_process(struct honeyuser *user, struct evbuffer *evbuf)$/;"	f
record_remove_hashes	stats.c	/^record_remove_hashes(struct hashq *hashes)$/;"	f
record_tags	tagging.h	/^} record_tags;$/;"	v	typeref:enum:__anon7
record_unmarshal	untagging.c	/^int record_unmarshal(struct record *record, struct evbuffer *evbuf)$/;"	f
recv	honeyd_overload.c	/^ssize_t recv(int sock, void *buf, size_t len, int flags)$/;"	f
recvfrom	honeyd_overload.c	/^ssize_t recvfrom(int sock, void *buf, size_t len, int flags,$/;"	f
recvmsg	honeyd_overload.c	/^ssize_t recvmsg(int sock, struct msghdr *msg, int flags)$/;"	f
red	router.h	/^	struct link_drop red;	\/* Random Early Drop thresholds *\/$/;"	m	struct:link_entry	typeref:struct:link_entry::link_drop
refcnt	template.h	/^	uint16_t refcnt;$/;"	m	struct:__anon9
regression_coefficients	FPModelConverted.h	/^static double regression_coefficients[] = {$/;"	v
rejected_ipv6_addr	randomipv6.h	/^struct rejected_ipv6_addr{$/;"	s
report	analyze.h	/^struct report {$/;"	s
report	filter.h	/^	void *report;$/;"	m	struct:filter
report_compare	analyze.c	/^static int report_compare(struct report *a, struct report *b)$/;"	f	file:
report_create	analyze.c	/^report_create(struct kctree *kctree,$/;"	f
report_free	analyze.c	/^void report_free(struct reporttree *tree)$/;"	f
report_print	analyze.c	/^void report_print(struct reporttree *tree, FILE *out,$/;"	f
report_to_file	analyze.c	/^void report_to_file(struct reporttree *tree, char *filename,$/;"	f
reserved	personality.h	/^		reserved:7;$/;"	m	struct:personality
reserved	stats.h	/^		reserved:4;$/;"	m	struct:stats
response	personality.h	/^	uint8_t response;$/;"	m	struct:persudp
result_from_cache	analyze.c	/^	int result_from_cache;$/;"	m	struct:country_state	file:
retrans_time	honeyd.h	/^	u_short retrans_time;$/;"	m	struct:tcp_con
retrans_timeout	honeyd.h	/^	struct event retrans_timeout;$/;"	m	struct:tcp_con	typeref:struct:tcp_con::event
reverse	router.c	/^struct network *reverse = NULL;$/;"	v	typeref:struct:network
reverse6	router.c	/^struct network *reverse6 = NULL;$/;"	v	typeref:struct:network
rid	personality.h	/^	enum rval rid;$/;"	m	struct:persudp	typeref:enum:persudp::rval
right	network.h	/^	struct network *right;$/;"	m	struct:network	typeref:struct:network::network
ripck	personality.h	/^	enum rval ripck;$/;"	m	struct:persudp	typeref:enum:persudp::rval
riplen	personality.h	/^	int riplen;$/;"	m	struct:persudp
rlen	honeyd.h	/^	u_int rlen;$/;"	m	struct:tcp_con
rlen	subsystem.h	/^	socklen_t rlen;$/;"	m	struct:subsystem_command
rol	sha1.c	33;"	d	file:
root	subsystem.h	/^	root;$/;"	m	struct:subsystem
route_type	router.h	/^enum route_type {ROUTE_LINK = 0, ROUTE_NET, ROUTE_UNREACH, ROUTE_TUNNEL};$/;"	g
router	router.h	/^struct router {$/;"	s
router_add_link	router.c	/^int router_add_link(struct router *r, struct addr *addr)$/;"	f
router_add_net	router.c	/^int router_add_net(struct router *r, struct addr *net, struct router *gw,$/;"	f
router_add_tunnel	router.c	/^int router_add_tunnel(struct router *r, struct addr *net,$/;"	f
router_add_unreach	router.c	/^int router_add_unreach(struct router *r, struct addr *addr)$/;"	f
router_adv	icmp6.c	/^struct router_advertisement * router_adv = NULL;$/;"	v	typeref:struct:router_advertisement
router_advertisement	icmp6.h	/^struct router_advertisement{$/;"	s
router_end	router.c	/^void router_end(void)$/;"	f
router_entry	router.h	/^struct router_entry {$/;"	s
router_entry_new	router.c	/^router_entry_new(struct addr *net, struct router *parent, struct router *gw,$/;"	f
router_find	router.c	/^router_find(struct addr *addr)$/;"	f
router_find_tunnel	router.c	/^router_find_tunnel(struct addr *src, struct addr *dst)$/;"	f
router_init	router.c	/^void router_init(void)$/;"	f
router_new	router.c	/^router_new(struct addr *addr)$/;"	f
router_sol_ev	icmp6.c	/^struct event *router_sol_ev;$/;"	v	typeref:struct:event
router_sol_tv	icmp6.c	/^struct timeval *router_sol_tv;$/;"	v	typeref:struct:timeval
router_start	router.c	/^int router_start(struct addr *addr, struct addr *pnetwork)$/;"	f
router_used	router.c	/^int router_used = 0;$/;"	v
routercompare	router.c	/^int routercompare(struct router *a, struct router *b)$/;"	f
routes	router.h	/^	struct network *routes;$/;"	m	struct:router	typeref:struct:router::network
rrd_file	rrdtool.h	/^	char rrd_file[512];$/;"	m	struct:rrdtool_db
rrdtool_command	rrdtool.c	/^rrdtool_command(struct rrdtool_drv *drv, char *command,$/;"	f
rrdtool_command	rrdtool.h	/^struct rrdtool_command$/;"	s
rrdtool_command_done	rrdtool.c	/^rrdtool_command_done(struct rrdtool_drv *drv, char *result)$/;"	f
rrdtool_db	rrdtool.h	/^struct rrdtool_db$/;"	s
rrdtool_db_commit	rrdtool.c	/^rrdtool_db_commit(struct rrdtool_db *db)$/;"	f
rrdtool_db_commit_cb	rrdtool.c	/^rrdtool_db_commit_cb(char *result, void *arg)$/;"	f	file:
rrdtool_db_datasource	rrdtool.c	/^rrdtool_db_datasource(struct rrdtool_db *db, char *name, char *type,$/;"	f
rrdtool_db_free	rrdtool.c	/^rrdtool_db_free(struct rrdtool_db *db)$/;"	f
rrdtool_db_start	rrdtool.c	/^rrdtool_db_start(struct rrdtool_drv *drv, char *filename, int stepsize)$/;"	f
rrdtool_db_update	rrdtool.c	/^rrdtool_db_update(struct rrdtool_db *db, struct timeval *tv, char *update)$/;"	f
rrdtool_drv	rrdtool.h	/^struct rrdtool_drv$/;"	s
rrdtool_evb_errcb	rrdtool.c	/^rrdtool_evb_errcb(struct bufferevent *bev, short what, void *parameter)$/;"	f
rrdtool_evb_readcb	rrdtool.c	/^rrdtool_evb_readcb(struct bufferevent *bev, void *parameter)$/;"	f
rrdtool_evb_writecb	rrdtool.c	/^rrdtool_evb_writecb(struct bufferevent *bev, void *parameter)$/;"	f
rrdtool_fork	rrdtool.c	/^rrdtool_fork(struct rrdtool_drv *drv)$/;"	f
rrdtool_free	rrdtool.c	/^rrdtool_free(struct rrdtool_drv *drv)$/;"	f
rrdtool_graph	rrdtool.c	/^rrdtool_graph(struct rrdtool_db *db, char *filename,$/;"	f
rrdtool_init	rrdtool.c	/^rrdtool_init(const char *path_rrdtool)$/;"	f
rrdtool_restart	rrdtool.c	/^rrdtool_restart(int fd, short what, void *arg)$/;"	f	file:
rrdtool_test	rrdtool.c	/^rrdtool_test(void)$/;"	f
rrdtool_test_done	rrdtool.c	/^rrdtool_test_done(char *something, void *arg)$/;"	f
rrdtool_write_command	rrdtool.c	/^rrdtool_write_command(struct rrdtool_drv *drv, char *command)$/;"	f	file:
rsa	honeyd_overload.c	/^	struct sockaddr_storage rsa; \/* remote address *\/$/;"	m	struct:fd	typeref:struct:fd::sockaddr_storage	file:
rsalen	honeyd_overload.c	/^	socklen_t rsalen;$/;"	m	struct:fd	file:
rsize	honeyd.h	/^	u_int rsize;$/;"	m	struct:tcp_con
rsockaddr	subsystem.h	/^	struct sockaddr_storage rsockaddr;$/;"	m	struct:subsystem_command	typeref:struct:subsystem_command::sockaddr_storage
rval	personality.h	/^enum rval { RVAL_OKAY = 0, RVAL_ZERO, RVAL_BAD };$/;"	g
sa	honeyd_overload.c	/^	struct sockaddr_storage sa; \/* address we bound to *\/$/;"	m	struct:fd	typeref:struct:fd::sockaddr_storage	file:
salen	honeyd_overload.c	/^	socklen_t salen;$/;"	m	struct:fd	file:
sawtimestamp	honeyd.h	/^	uint8_t sentfin :1, finacked :1, sawwscale :1, sawtimestamp :1, unused :4;$/;"	m	struct:tcp_con
sawwscale	honeyd.h	/^	uint8_t sentfin :1, finacked :1, sawwscale :1, sawtimestamp :1, unused :4;$/;"	m	struct:tcp_con
sax_hash	bloom.c	/^unsigned int sax_hash(const char *key)$/;"	f
sc	stats.c	/^struct statscontrol sc;$/;"	v	typeref:struct:statscontrol
schedule_router_solicitation	icmp6.c	/^void schedule_router_solicitation(void)$/;"	f
sdbm_hash	bloom.c	/^unsigned int sdbm_hash(const char *key)$/;"	f
seconds	histogram.h	/^	struct entryq seconds;$/;"	m	struct:count	typeref:struct:count::entryq
security_update	update.c	/^char *security_update = NULL;$/;"	v
segments	hsniff.h	/^	TAILQ_HEAD(tcpq, tcp_segment) segments;$/;"	m	struct:tcp_track
select	honeyd_overload.c	/^int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,$/;"	f
send_cmd	honeyd_overload.c	/^static int send_cmd(struct subsystem_command *cmd)$/;"	f	file:
send_fd	fdpass.c	/^int send_fd(int socket, int fd, void *base, size_t len)$/;"	f
send_router_solicitation_cb	icmp6.c	/^void send_router_solicitation_cb(int fd, short event, void *arg)$/;"	f
sendmsg	honeyd_overload.c	/^ssize_t sendmsg(int sock, const struct msghdr *msg, int flags)$/;"	f
sendto	honeyd_overload.c	/^ssize_t sendto(int sock, const void *buf, size_t len, int flags,$/;"	f
sent	honeyd.h	/^	uint32_t sent;$/;"	m	struct:tuple
sentfin	honeyd.h	/^	uint8_t sentfin :1, finacked :1, sawwscale :1, sawtimestamp :1, unused :4;$/;"	m	struct:tcp_con
seq	hsniff.h	/^	uint32_t seq;$/;"	m	struct:tcp_segment
seq	template.h	/^	uint32_t seq;$/;"	m	struct:__anon9
seqcalls	template.h	/^	int seqcalls;$/;"	m	struct:__anon9
seqindex_aconst	personality.h	/^	double seqindex_aconst;$/;"	m	struct:personality
seqindex_amax	personality.h	/^	double seqindex_amax;$/;"	m	struct:personality
seqindex_amin	personality.h	/^	double seqindex_amin;	\/* Values calculated from seqindex_{min,max} *\/$/;"	m	struct:personality
seqindex_max	personality.h	/^	uint32_t seqindex_max;$/;"	m	struct:personality
seqindex_min	personality.h	/^	uint32_t seqindex_min;$/;"	m	struct:personality
seqnr	honeydstats.h	/^	uint32_t seqnr;		\/* last sequence number *\/$/;"	m	struct:honeyuser
seqt	personality.h	/^	enum seqtype seqt;$/;"	m	struct:personality	typeref:enum:personality::seqtype
seqtype	personality.h	/^enum seqtype {SEQ_CLASS64K, SEQ_RI, SEQ_TRIVIALTIME, SEQ_RANDOM,$/;"	g
server_ea	dhcpclient.h	/^	eth_addr_t	server_ea;	\/* from the server *\/$/;"	m	struct:dhcpclient_req
servicelog	honeyd.c	/^static char *servicelog = NULL;$/;"	v	file:
servident	dhcpclient.h	/^	struct addr     servident;$/;"	m	struct:dhcpclient_req	typeref:struct:dhcpclient_req::addr
set_IPv6_addr_type_and_bits	icmp6.c	/^void set_IPv6_addr_type_and_bits(struct addr * address)$/;"	f
set_icmpv6_type_and_code_for_echo_reply	icmp6.c	/^void set_icmpv6_type_and_code_for_echo_reply(struct icmp6_hdr *icmp6_response_hdr)$/;"	f
set_icmpv6_type_and_code_for_ns	icmp6.c	/^void set_icmpv6_type_and_code_for_ns(struct nd_neighbor_solicit *neighbor_solicit)$/;"	f
set_icmpv6_type_and_code_for_rs	icmp6.c	/^void set_icmpv6_type_and_code_for_rs(struct nd_router_solicit *router_solicit)$/;"	f
set_source_eth_option_in_ns	icmp6.c	/^void set_source_eth_option_in_ns(struct nd_opt_hdr* opt,struct addr * src_eth_addr)$/;"	f
set_xp_struct	personality.c	/^set_xp_struct(struct xp_fingerprint *pers, char *line)$/;"	f	file:
setsockopt	honeyd_overload.c	/^int setsockopt(int sock, int level, int optname, const void *optval,$/;"	f
setup_socket	honeydstats_main.c	/^void setup_socket(char *address, int port)$/;"	f
short	parse.c	395;"	d	file:
short_help	ui.c	/^	char *short_help;$/;"	m	struct:command	file:
signature	stats.h	/^struct signature {$/;"	s
signature_length	honeydstats.c	/^static int signature_length(struct evbuffer *evbuf)$/;"	f	file:
signature_process	honeydstats.c	/^int signature_process(struct evbuffer *evbuf)$/;"	f
signature_tags	stats.h	/^} signature_tags;$/;"	v	typeref:enum:__anon6
size	ipfrag.h	/^	u_short size;$/;"	m	struct:fragent
size	pool.h	/^	size_t size;$/;"	m	struct:pool
size	pool.h	/^	size_t size;$/;"	m	struct:pool_entry
size	pyextend.c	/^	size_t size;$/;"	m	struct:pywrite	file:
smartgets	honeydctl.c	/^smartgets(EditLine *e, int *count, int fd)$/;"	f
snd_una	honeyd.h	/^	uint32_t snd_una;$/;"	m	struct:tcp_con
snd_una	hsniff.h	/^	uint32_t snd_una;$/;"	m	struct:tcp_track
sockaddr	subsystem.h	/^	struct sockaddr_storage sockaddr;$/;"	m	struct:subsystem_command	typeref:struct:subsystem_command::sockaddr_storage
sockaddr_storage	subsystem.h	/^struct sockaddr_storage$/;"	s
socket	honeyd_overload.c	/^int socket(int domain, int type, int protocol)$/;"	f
softerrors	honeyd.h	/^	int softerrors; \/* ICMP unreachables for this state *\/$/;"	m	struct:udp_con
sort_name_list	pfctl_osfp.c	/^void sort_name_list(int opts, struct name_list *nml)$/;"	f
source_code	pydataprocessing.h	/^	char *source_code;			\/* available on original *\/$/;"	m	struct:PyFilter
source_ip_addr	icmp6.h	/^	struct addr source_ip_addr;$/;"	m	struct:ndp_neighbor_req	typeref:struct:ndp_neighbor_req::addr
source_mac_addr	icmp6.h	/^	struct addr source_mac_addr;$/;"	m	struct:ndp_neighbor_req	typeref:struct:ndp_neighbor_req::addr
spammer_key_extract	analyze.c	/^void spammer_key_extract(struct keycount *keycount, void **pkey,$/;"	f
spammer_key_print	analyze.c	/^spammer_key_print(void *key, size_t keylen)$/;"	f
spammer_report_file	analyze.c	/^char *spammer_report_file = NULL;$/;"	v
spammers	analyze.c	/^struct kctree spammers;$/;"	v	typeref:struct:kctree
spoof	honeyd.h	/^	struct spoof spoof;$/;"	m	struct:delay	typeref:struct:delay::spoof
spoof	honeyd.h	/^struct spoof$/;"	s
spoof	template.h	/^	struct spoof spoof;$/;"	m	struct:__anon9	typeref:struct:__anon9::spoof
sport	honeyd.h	/^	uint16_t sport;$/;"	m	struct:tuple
src	analyze.c	/^	struct addr src;$/;"	m	struct:country_state	typeref:struct:country_state::addr	file:
src	analyze.c	/^	struct reporttree *src;$/;"	m	struct:filterarg	typeref:struct:filterarg::reporttree	file:
src	honeyd.h	/^	struct addr src;$/;"	m	struct:delay	typeref:struct:delay::addr
src	honeyd_overload.h	/^	struct sockaddr_in src;$/;"	m	struct:bundle	typeref:struct:bundle::sockaddr_in
src	osfp.h	/^	ip_addr_t	src;$/;"	m	struct:osfp
src	pyextend.h	/^	struct addr src;$/;"	m	struct:pyextend_request	typeref:struct:pyextend_request::addr
src	tagging.h	/^	struct addr src;$/;"	m	struct:record	typeref:struct:record::addr
src_addr	honeyd.h	/^	struct addr src_addr;$/;"	m	struct:tuple	typeref:struct:tuple::addr
src_addr	ip6frag.h	/^	struct addr src_addr;$/;"	m	struct:fragment6	typeref:struct:fragment6::addr
src_eth_addr	icmp6.h	/^	struct addr src_eth_addr;	$/;"	m	struct:router_advertisement	typeref:struct:router_advertisement::addr
src_ha	arp.h	/^	struct addr		src_ha;$/;"	m	struct:arp_req	typeref:struct:arp_req::addr
src_pa	arp.h	/^	struct addr		src_pa;$/;"	m	struct:arp_req	typeref:struct:arp_req::addr
src_port	tagging.h	/^	uint16_t src_port;$/;"	m	struct:record
start	personality.c	/^	char *start;$/;"	m	struct:parse_test	file:
state	dhcpclient.h	/^	int             state;$/;"	m	struct:dhcpclient_req
state	honeyd.h	/^	uint8_t state;$/;"	m	struct:tcp_con
state	honeyd.h	/^	void *state; \/* Currently used only for Python *\/$/;"	m	struct:command
state	pyextend.c	/^	PyObject *state;$/;"	m	struct:pystate	file:
state	tagging.h	/^	uint8_t state;$/;"	m	struct:record
stats	stats.h	/^struct stats {$/;"	s
stats_activate	stats.c	/^stats_activate(struct stats *stats)$/;"	f	file:
stats_add_timeout	stats.c	/^stats_add_timeout(struct stats *stats)$/;"	f	file:
stats_compress	stats.c	/^stats_compress(struct evbuffer *evbuf)$/;"	f
stats_compress_test	stats.c	/^stats_compress_test()$/;"	f
stats_deactivate	stats.c	/^stats_deactivate(struct stats *stats)$/;"	f	file:
stats_decompress	stats.c	/^stats_decompress(struct evbuffer *evbuf)$/;"	f
stats_fd	stats.c	/^	int stats_fd;$/;"	m	struct:statscontrol	file:
stats_find	stats.c	/^stats_find(const struct tuple *conhdr)$/;"	f	file:
stats_free	stats.c	/^stats_free(struct stats *stats)$/;"	f
stats_hmac_test	stats.c	/^stats_hmac_test()$/;"	f
stats_init	stats.c	/^stats_init()$/;"	f
stats_init_collect	stats.c	/^stats_init_collect(struct addr *dst, u_short port, char *name, char *password)$/;"	f
stats_make_fd	stats.c	/^stats_make_fd(struct addr *dst, u_short port)$/;"	f	file:
stats_measure_cb	stats.c	/^stats_measure_cb(int fd, short what, void *arg)$/;"	f	file:
stats_measure_timeout	stats.c	/^stats_measure_timeout(void)$/;"	f	file:
stats_network	honeyd.c	/^struct stats_network stats_network =$/;"	v	typeref:struct:stats_network
stats_network	honeyd.h	/^struct stats_network$/;"	s
stats_new	stats.c	/^stats_new(const struct tuple *conhdr)$/;"	f
stats_package_measurement	stats.c	/^stats_package_measurement()$/;"	f	file:
stats_packet	stats.h	/^struct stats_packet {$/;"	s
stats_prepare_send	stats.c	/^stats_prepare_send(struct evbuffer *evbuf)$/;"	f	file:
stats_process_data	stats.c	/^stats_process_data(struct stats *stats, void *data, u_int len)$/;"	f	file:
stats_reactivate	stats.c	/^stats_reactivate(struct stats *stats)$/;"	f	file:
stats_ready_cb	stats.c	/^stats_ready_cb(int fd, short what, void *arg)$/;"	f	file:
stats_register_cb	stats.c	/^stats_register_cb(int (*cb)(const struct record *, void *), void *cb_arg)$/;"	f
stats_shingle_data	stats.c	/^stats_shingle_data(struct stats *stats)$/;"	f	file:
stats_tcp_data	stats.c	/^stats_tcp_data(struct tuple *conhdr, u_char *pkt, u_int pktlen, void *arg)$/;"	f	file:
stats_tcp_input	stats.c	/^stats_tcp_input(struct tuple *conhdr, u_char *pkt, u_int pktlen, void *arg)$/;"	f	file:
stats_test	stats.c	/^stats_test(void)$/;"	f
stats_timeout_cb	stats.c	/^stats_timeout_cb(int fd, short what, void *arg)$/;"	f	file:
stats_udp_data	stats.c	/^stats_udp_data(struct tuple *conhdr, u_char *pkt, u_int pktlen, void *arg)$/;"	f	file:
stats_udp_input	stats.c	/^stats_udp_input(struct tuple *conhdr, u_char *pkt, u_int pktlen, void *arg)$/;"	f	file:
statscb	stats.c	/^struct statscb {$/;"	s	file:
statscontrol	stats.c	/^struct statscontrol {$/;"	s	file:
status	honeyd.h	/^	enum status status;$/;"	m	struct:action	typeref:enum:action::status
status	honeyd.h	/^enum status$/;"	g
store_in_router_cache	icmp6.c	/^void store_in_router_cache(struct router_advertisement *advertisement)$/;"	f
string	parse.c	/^	char *string;$/;"	m	union:YYSTYPE	file:
string	parse.h	/^	char *string;$/;"	m	union:YYSTYPE
strlcat	strlcat.c	/^strlcat(dst, src, siz)$/;"	f
strlcpy	strlcpy.c	/^size_t strlcpy(dst, src, siz)$/;"	f
strnsep	util.c	/^strnsep(char **line, char *delim)$/;"	f
strrpl	util.c	/^strrpl(char *str, size_t size, char *match, char *value)$/;"	f
strsep	strsep.c	/^strsep(char **stringp, const char *delim)$/;"	f
sub	honeyd.h	/^	struct subsystem *sub;$/;"	m	struct:port	typeref:struct:port::subsystem
sub	template.h	/^	struct subsystem *sub;$/;"	m	struct:subsystem_container	typeref:struct:subsystem_container::subsystem
sub_conport	honeyd.h	/^	struct port **sub_conport;$/;"	m	struct:port	typeref:struct:port::port
sub_fd	honeyd.h	/^	int sub_fd;$/;"	m	struct:port
sub_islisten	honeyd.h	/^	int sub_islisten;$/;"	m	struct:port
subaddr	network.c	/^void subaddr(struct addr * source_addr, struct addr * target_addr, int prefix){$/;"	f
subcmd	subsystem.h	/^enum subcmd$/;"	g
subsystem	subsystem.h	/^struct subsystem$/;"	s
subsystem_bind	subsystem.c	/^subsystem_bind(int fd, struct template *tmpl, struct subsystem *sub,$/;"	f
subsystem_cb	subsystem.c	/^struct callback subsystem_cb = {$/;"	v	typeref:struct:callback
subsystem_cleanup	subsystem.c	/^subsystem_cleanup(struct subsystem *sub)$/;"	f
subsystem_cmd_listen	subsystem.c	/^subsystem_cmd_listen(int fd,$/;"	f
subsystem_command	subsystem.h	/^struct subsystem_command$/;"	s
subsystem_container	template.h	/^struct subsystem_container$/;"	s
subsystem_findport	subsystem.c	/^subsystem_findport(struct subsystem *sub, char *name, int proto)$/;"	f
subsystem_insert_template	subsystem.c	/^subsystem_insert_template(struct subsystem *sub, struct template *tmpl)$/;"	f
subsystem_listen	subsystem.c	/^subsystem_listen(struct port *sub_port, char *ip, int nfd)$/;"	f
subsystem_print	subsystem.c	/^subsystem_print(struct evbuffer *buffer, struct subsystem *sub)$/;"	f
subsystem_read	subsystem.c	/^subsystem_read(int fd, short what, void *arg)$/;"	f
subsystem_readyport	subsystem.c	/^subsystem_readyport(struct port *port, struct subsystem *sub,$/;"	f
subsystem_restart	subsystem.c	/^subsystem_restart(int fd, short what, void *arg)$/;"	f
subsystem_socket	subsystem.c	/^subsystem_socket(struct subsystem_command *cmd, int local,$/;"	f
subsystem_template_find	subsystem.c	/^subsystem_template_find(struct subsystem *sub, char *name)$/;"	f
subsystem_write	subsystem.c	/^subsystem_write(int fd, short what, void *arg)$/;"	f
subsystems	config.c	/^struct subsystemqueue subsystems;$/;"	v	typeref:struct:subsystemqueue
subsystems	template.h	/^	subsystems;$/;"	m	struct:__anon9
subtmpl	honeyd.h	/^	struct template *subtmpl;$/;"	m	struct:port	typeref:struct:port::
syslog_init	honeyd.c	/^static void syslog_init(int argc, char *argv[])$/;"	f	file:
syslog_init	honeydstats_main.c	/^void syslog_init(int argc, char *argv[])$/;"	f
syslog_init	hsniff.c	/^static void syslog_init(int argc, char *argv[])$/;"	f	file:
tag_consume	untagging.c	/^int tag_consume(struct evbuffer *evbuf)$/;"	f
tag_marshal	tagging.c	/^tag_marshal(struct evbuffer *evbuf, uint8_t tag, void *data, uint16_t len)$/;"	f
tag_marshal_int	tagging.c	/^tag_marshal_int(struct evbuffer *evbuf, uint8_t tag, uint32_t integer)$/;"	f
tag_marshal_record	tagging.c	/^tag_marshal_record(struct evbuffer *evbuf, uint8_t tag, struct record *record)$/;"	f
tag_marshal_string	tagging.c	/^tag_marshal_string(struct evbuffer *buf, uint8_t tag, char *string)$/;"	f
tag_marshal_timeval	tagging.c	/^tag_marshal_timeval(struct evbuffer *evbuf, uint8_t tag, struct timeval *tv)$/;"	f
tag_peek	untagging.c	/^int tag_peek(struct evbuffer *evbuf, uint8_t *ptag)$/;"	f
tag_peek_length	untagging.c	/^int tag_peek_length(struct evbuffer *evbuf, uint32_t *plength)$/;"	f
tag_unmarshal	untagging.c	/^int tag_unmarshal(struct evbuffer *src, uint8_t *ptag, struct evbuffer *dst)$/;"	f
tag_unmarshal_fixed	untagging.c	/^int tag_unmarshal_fixed(struct evbuffer *src, uint8_t need_tag, void *data,$/;"	f
tag_unmarshal_int	untagging.c	/^int tag_unmarshal_int(struct evbuffer *evbuf, uint8_t need_tag,$/;"	f
tag_unmarshal_record	untagging.c	/^int tag_unmarshal_record(struct evbuffer *evbuf, uint8_t need_tag,$/;"	f
tag_unmarshal_string	untagging.c	/^int tag_unmarshal_string(struct evbuffer *evbuf, uint8_t need_tag,$/;"	f
tag_unmarshal_timeval	untagging.c	/^int tag_unmarshal_timeval(struct evbuffer *evbuf, uint8_t need_tag,$/;"	f
tagging_addr_test	untagging.c	/^void tagging_addr_test(void)$/;"	f
tagging_fuzz	untagging.c	/^void tagging_fuzz()$/;"	f
tagging_init	tagging.c	/^tagging_init()$/;"	f
tagging_int_test	untagging.c	/^void tagging_int_test(void)$/;"	f
tagging_record_test	untagging.c	/^void tagging_record_test(void)$/;"	f
tagging_test	untagging.c	/^void tagging_test(void)$/;"	f
target_ip_addr	icmp6.h	/^	struct addr target_ip_addr;$/;"	m	struct:ndp_neighbor_req	typeref:struct:ndp_neighbor_req::addr
target_mac_addr	icmp6.h	/^	struct addr target_mac_addr;$/;"	m	struct:ndp_neighbor_req	typeref:struct:ndp_neighbor_req::addr
tcp	template.h	/^	struct action tcp;$/;"	m	struct:__anon9	typeref:struct:__anon9::action
tcp_add_readbuf	tcp.c	/^int tcp_add_readbuf(struct tcp_con *con, u_char *dat, u_int datlen)$/;"	f
tcp_con	honeyd.h	/^struct tcp_con$/;"	s
tcp_connectfail	honeyd.c	/^void tcp_connectfail(struct tcp_con *con)$/;"	f
tcp_do_options	honeyd.c	/^void tcp_do_options(struct tcp_con *con, struct tcp_hdr *tcp, int isonsyn)$/;"	f
tcp_drain_payload	tcp.c	/^void tcp_drain_payload(struct tcp_con *con, u_int len)$/;"	f
tcp_drop_subsumed	hsniff.c	/^void tcp_drop_subsumed(struct tcp_track *con)$/;"	f
tcp_free	honeyd.c	/^void tcp_free(struct tcp_con *con)$/;"	f
tcp_increase_buf	tcp.c	/^void tcp_increase_buf(u_char **pbuf, u_int *psize, u_int maxsize)$/;"	f
tcp_insert	hsniff.c	/^void tcp_insert(struct tcp_track *con, uint32_t th_seq, void *data, size_t dlen)$/;"	f
tcp_new	honeyd.c	/^tcp_new(struct ip_hdr *ip, struct tcp_hdr *tcp, int local)$/;"	f
tcp_new46	honeyd.c	/^tcp_new46(struct ip_hdr *ip, struct ip6_hdr *ip6, struct tcp_hdr *tcp,$/;"	f
tcp_new6	honeyd.c	/^tcp_new6(struct ip6_hdr *ip6, struct tcp_hdr *tcp, int local)$/;"	f
tcp_personality	personality.c	/^tcp_personality(struct tcp_con *con, uint8_t *pflags, int *pwindow, int *pdf,$/;"	f
tcp_personality_match	personality.c	/^tcp_personality_match(struct tcp_con *con, int flags)$/;"	f
tcp_personality_options	personality.c	/^tcp_personality_options(struct tcp_con *con, struct tcp_hdr *tcp,$/;"	f
tcp_personality_seq	personality.c	/^tcp_personality_seq(struct template *tmpl, struct personality *person)$/;"	f
tcp_personality_seqinit	personality.c	/^tcp_personality_seqinit(struct personality *person)$/;"	f
tcp_personality_test	personality.c	/^tcp_personality_test(const struct tcp_con *con, struct personality *person,$/;"	f
tcp_personality_time	personality.c	/^tcp_personality_time(struct template *tmpl, struct timeval *diff)$/;"	f
tcp_recv_cb	honeyd.c	/^void tcp_recv_cb(struct template *tmpl, u_char *pkt, u_short pktlen)$/;"	f
tcp_recv_cb	hsniff.c	/^void tcp_recv_cb(u_char *pkt, u_short pktlen)$/;"	f
tcp_recv_cb46	honeyd.c	/^void tcp_recv_cb46(struct template *tmpl, u_char *pkt, u_short pktlen,$/;"	f
tcp_recv_cb6	honeyd.c	/^void tcp_recv_cb6(struct template *tmpl, u_char *pkt, u_short pktlen)$/;"	f
tcp_retrans_timeout	honeyd.c	/^void tcp_retrans_timeout(int fd, short event, void *arg)$/;"	f
tcp_segment	hsniff.h	/^struct tcp_segment {$/;"	s
tcp_send	honeyd.c	/^int tcp_send(struct tcp_con *con, uint8_t flags, u_char *payload, u_int len)$/;"	f
tcp_send46	honeyd.c	/^int tcp_send46(struct tcp_con *con, uint8_t flags, u_char *payload, u_int len,$/;"	f
tcp_senddata	honeyd.c	/^void tcp_senddata(struct tcp_con *con, uint8_t flags)$/;"	f
tcp_senddata46	honeyd.c	/^void tcp_senddata46(struct tcp_con *con, uint8_t flags, int addr_family)$/;"	f
tcp_sendfin	honeyd.c	/^void tcp_sendfin(struct tcp_con *con)$/;"	f
tcp_sendfin46	honeyd.c	/^void tcp_sendfin46(struct tcp_con *con, int addr_family)$/;"	f
tcp_setupconnect	honeyd.c	/^int tcp_setupconnect(struct tcp_con *con)$/;"	f
tcp_track	hsniff.h	/^struct tcp_track {$/;"	s
tcp_track_free	hsniff.c	/^void tcp_track_free(struct tcp_track *con)$/;"	f
tcp_track_new	hsniff.c	/^tcp_track_new(struct ip_hdr *ip, struct tcp_hdr *tcp, int local)$/;"	f
tcpcons	honeyd.c	/^struct tree tcpcons;$/;"	v	typeref:struct:tree
tcpcons	hsniff.c	/^struct tree tcpcons;$/;"	v	typeref:struct:tree
tcplru	honeyd.c	/^struct conlru tcplru;$/;"	v	typeref:struct:conlru
templ_compare	config.c	/^templ_compare(struct template *a, struct template *b)$/;"	f
templ_container_compare	subsystem.c	/^templ_container_compare(struct template_container *a,$/;"	f
template_add	config.c	/^template_add(struct template *tmpl, int proto, int number,$/;"	f
template_clone	config.c	/^template_clone(const char *newname, const struct template *tmpl, $/;"	f
template_container	subsystem.h	/^struct template_container$/;"	s
template_create	config.c	/^template_create(const char *name)$/;"	f
template_deallocate	config.c	/^template_deallocate(struct template *tmpl)$/;"	f
template_delay_cb	config.c	/^template_delay_cb(int fd, short which, void *arg)$/;"	f
template_dynamic	config.c	/^template_dynamic(const struct template *tmpl, const struct ip_hdr *ip,$/;"	f
template_find	config.c	/^template_find(const char *name)$/;"	f
template_find_best	config.c	/^template_find_best(const char *addr, const struct ip_hdr *ip, u_short iplen)$/;"	f
template_find_mock	icmp6.c	/^struct template *template_find_mock(const char *ip_addr_str)$/;"	f
template_free	template.h	162;"	d
template_free_all	config.c	/^template_free_all(int how)$/;"	f
template_get_dhcp_address	config.c	/^template_get_dhcp_address(struct addr *addr)$/;"	f
template_insert	config.c	/^template_insert(struct template *tmpl)$/;"	f
template_insert_dynamic	config.c	/^template_insert_dynamic(struct template *tmpl, struct template *child,$/;"	f
template_insert_subsystem	config.c	/^template_insert_subsystem(struct template *tmpl, struct subsystem *sub)$/;"	f
template_iterate	config.c	/^template_iterate(int (*f)(struct template *, void *), void *arg)$/;"	f
template_list_glob	config.c	/^template_list_glob(struct evbuffer *buffer, const char *pattern)$/;"	f
template_packet_test	config.c	/^template_packet_test(void)$/;"	f
template_post_arp	config.c	/^template_post_arp(struct template *tmpl, struct addr *ipaddr)$/;"	f
template_post_ndp	config.c	/^template_post_ndp(struct template *tmpl, struct addr *ipaddr){$/;"	f
template_print	config.c	/^template_print(struct evbuffer *buffer, struct template *tmpl)$/;"	f
template_ref	template.h	/^template_ref(struct template *tmpl)$/;"	f
template_remove	config.c	/^template_remove(struct template *tmpl)$/;"	f
template_remove_arp	config.c	/^template_remove_arp(struct template *tmpl)$/;"	f
template_remove_subsystem	config.c	/^template_remove_subsystem(struct template *tmpl, struct subsystem *sub)$/;"	f
template_subsystem	config.c	/^template_subsystem(struct template *tmpl, char *subsystem, int flags)$/;"	f
template_subsystem_find	config.c	/^template_subsystem_find(const char *name)$/;"	f
template_subsystem_free	config.c	/^template_subsystem_free(struct subsystem *sub)$/;"	f
template_subsystem_free_ports	config.c	/^template_subsystem_free_ports(struct subsystem *sub)$/;"	f
template_subsystem_list_glob	config.c	/^template_subsystem_list_glob(struct evbuffer *buffer, const char *pattern)$/;"	f
template_subsystem_start	config.c	/^template_subsystem_start(struct template *tmpl, struct subsystem *sub)$/;"	f
template_test	config.c	/^template_test(void)$/;"	f
template_test_add	config.c	/^template_test_add(struct evbuffer *evbuf, struct addr *addr, int count)$/;"	f
template_test_measure	config.c	/^template_test_measure(int count)$/;"	f
template_test_parse_error	config.c	/^template_test_parse_error(char *line, struct evbuffer *evbuf)$/;"	f
templates	config.c	/^struct templtree templates;$/;"	v	typeref:struct:templtree
templates	icmp6.h	/^	struct addr_tree templates;	$/;"	m	struct:multicast_group	typeref:struct:multicast_group::addr_tree
templates	subsystem.h	/^	templates;$/;"	m	struct:subsystem
test_handle_neighbor_solicitation	icmp6.c	/^void test_handle_neighbor_solicitation()$/;"	f
test_ndp_neighbor_delete	icmp6.c	/^void test_ndp_neighbor_delete(void)$/;"	f
test_ndp_neighbor_new	icmp6.c	/^void test_ndp_neighbor_new(void)$/;"	f
tests	personality.h	/^	struct personate tests[7];$/;"	m	struct:personality	typeref:struct:personality::personate
their_fd	honeyd_overload.c	/^	int their_fd;$/;"	m	struct:fd	file:
this_fd	honeyd_overload.c	/^	int this_fd;$/;"	m	struct:fd	file:
time	parse.c	/^	struct tm time;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::tm	file:
time	parse.h	/^	struct tm time;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::tm
timecondition	parse.c	/^	struct condition_time timecondition;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::condition_time	file:
timecondition	parse.h	/^	struct condition_time timecondition;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::condition_time
timeentry	keycount.h	/^struct timeentry$/;"	s
timekey	keycount.h	/^struct timekey$/;"	s
timekey_compare	keycount.c	/^timekey_compare(struct timekey *a, struct timekey *b)$/;"	f	file:
timekey_new	keycount.c	/^timekey_new(const void *key, size_t keylen)$/;"	f
timeout	honeyd.h	/^	struct event timeout;$/;"	m	struct:delay	typeref:struct:delay::event
timeout	honeyd.h	/^	struct event timeout;$/;"	m	struct:tuple	typeref:struct:tuple::event
timeout	hsniff.h	/^	struct event timeout;$/;"	m	struct:tcp_track	typeref:struct:tcp_track::event
timeout	ip6frag.h	/^	struct event timeout;$/;"	m	struct:fragment6	typeref:struct:fragment6::event
timeout	ipfrag.h	/^	struct event timeout;$/;"	m	struct:fragment	typeref:struct:fragment::event
timeout	osfp.h	/^	struct event timeout;$/;"	m	struct:osfp	typeref:struct:osfp::event
timeout_initialized	command.c	60;"	d	file:
timeout_initialized	condition.c	60;"	d	file:
timeout_initialized	config.c	62;"	d	file:
timeout_initialized	gre.c	56;"	d	file:
timeout_initialized	honeyd.c	71;"	d	file:
timeout_initialized	honeyd_overload.c	94;"	d	file:
timeout_initialized	honeydstats.c	68;"	d	file:
timeout_initialized	honeydstats_main.c	68;"	d	file:
timeout_initialized	hsniff.c	69;"	d	file:
timeout_initialized	ipfrag.c	57;"	d	file:
timeout_initialized	log.c	62;"	d	file:
timeout_initialized	network.c	53;"	d	file:
timeout_initialized	osfp.c	58;"	d	file:
timeout_initialized	personality.c	58;"	d	file:
timeout_initialized	pydatahoneyd.c	62;"	d	file:
timeout_initialized	pydataprocessing.c	62;"	d	file:
timeout_initialized	pyextend.c	61;"	d	file:
timeout_initialized	router.c	53;"	d	file:
timeout_initialized	subsystem.c	58;"	d	file:
timeout_initialized	tcp.c	55;"	d	file:
timeout_initialized	udp.c	57;"	d	file:
timeout_initialized	xprobe_assoc.c	83;"	d	file:
timeout_pending	command.c	59;"	d	file:
timeout_pending	condition.c	59;"	d	file:
timeout_pending	config.c	61;"	d	file:
timeout_pending	gre.c	55;"	d	file:
timeout_pending	honeyd.c	70;"	d	file:
timeout_pending	honeyd_overload.c	93;"	d	file:
timeout_pending	honeydstats.c	67;"	d	file:
timeout_pending	honeydstats_main.c	67;"	d	file:
timeout_pending	hsniff.c	68;"	d	file:
timeout_pending	ipfrag.c	56;"	d	file:
timeout_pending	log.c	61;"	d	file:
timeout_pending	network.c	52;"	d	file:
timeout_pending	osfp.c	57;"	d	file:
timeout_pending	personality.c	57;"	d	file:
timeout_pending	pydatahoneyd.c	61;"	d	file:
timeout_pending	pydataprocessing.c	61;"	d	file:
timeout_pending	pyextend.c	60;"	d	file:
timeout_pending	router.c	52;"	d	file:
timeout_pending	subsystem.c	57;"	d	file:
timeout_pending	tcp.c	54;"	d	file:
timeout_pending	udp.c	56;"	d	file:
timeout_pending	xprobe_assoc.c	82;"	d	file:
timeoutev	dhcpclient.h	/^	struct event    timeoutev;$/;"	m	struct:dhcpclient_req	typeref:struct:dhcpclient_req::event
timer	dhcpclient.h	/^	struct timeval  timer;$/;"	m	struct:dhcpclient_req	typeref:struct:dhcpclient_req::timeval
timeradd	acconfig.h	31;"	d
timeradd	config.h	33;"	d
timersub	acconfig.h	40;"	d
timersub	config.h	42;"	d
timeseries	keycount.h	/^struct timeseries$/;"	s
timeseries_compare	keycount.c	/^timeseries_compare(struct timeseries *a, struct timeseries *b)$/;"	f	file:
timeseries_init	keycount.c	/^timeseries_init()$/;"	f
timeseries_new	keycount.c	/^timeseries_new(char *name, struct kctree *kct, 	void (*extract)(struct keycount *, void **, size_t *),	void (*print)(void *, size_t), struct timeval *update)$/;"	f
timeseries_update	keycount.c	/^timeseries_update(struct timeval *tv)$/;"	f
timeseries_update_item	keycount.c	/^timeseries_update_item(struct timeseries *ts)$/;"	f
timestamp	template.h	/^	uint32_t timestamp;$/;"	m	struct:__anon9
timeupdate_compare	keycount.c	/^timeupdate_compare(struct timeseries *a, struct timeseries *b)$/;"	f	file:
tm_end	condition.h	/^	struct tm tm_end;$/;"	m	struct:condition_time	typeref:struct:condition_time::tm
tm_start	condition.h	/^	struct tm tm_start;$/;"	m	struct:condition_time	typeref:struct:condition_time::tm
tmpbuf	ui.c	/^char tmpbuf[1024];$/;"	v
tmpl	condition.h	/^	struct template *tmpl;$/;"	m	struct:condition	typeref:struct:condition::
tmpl	honeyd.h	/^	struct template *tmpl;$/;"	m	struct:delay	typeref:struct:delay::
tmpl	honeyd.h	/^	struct template *tmpl;$/;"	m	struct:tcp_con	typeref:struct:tcp_con::
tmpl	honeyd.h	/^	struct template *tmpl;$/;"	m	struct:udp_con	typeref:struct:udp_con::
tmpl	parse.c	/^	struct template *tmpl;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::template	file:
tmpl	parse.h	/^	struct template *tmpl;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::
tmpl	subsystem.h	/^	struct template *tmpl;$/;"	m	struct:template_container	typeref:struct:template_container::
tos	personality.h	/^	uint8_t tos;$/;"	m	struct:persudp
total_len	ip6frag.h	/^	uint32_t total_len;$/;"	m	struct:fragment6
trace	util.c	/^struct trace {$/;"	s	file:
trace_enter	util.c	/^trace_enter(int fd, char *line, int closed)$/;"	f
trace_free	util.c	/^trace_free(int fd)$/;"	f	file:
trace_init	util.c	/^trace_init(int fd)$/;"	f	file:
trace_inspect	util.c	/^trace_inspect(int fd, struct evbuffer *buffer)$/;"	f
trace_on	util.c	/^int trace_on;		\/* determines if we trace file descriptor calls *\/$/;"	v
trace_onoff	util.c	/^trace_onoff(int on) {$/;"	f
trace_refsize	util.c	/^static int trace_refsize;$/;"	v	file:
tree	keycount.h	/^	struct kctree *tree;$/;"	m	struct:timeseries	typeref:struct:timeseries::kctree
tstamphz	personality.h	/^        int tstamphz;		\/* -1 indicates undefined *\/$/;"	m	struct:personality
ttl_pair	personality.h	/^struct ttl_pair {$/;"	s
ttl_val	personality.h	/^	unsigned ttl_val:9;   \/\/ttl value (max TTL size is 9 bits)$/;"	m	struct:ttl_pair
ttl_vals	personality.h	/^	struct xp_fp_ttlvals ttl_vals; \/\/ttl values$/;"	m	struct:xp_fingerprint	typeref:struct:xp_fingerprint::xp_fp_ttlvals
tunnel_dst	router.h	/^	struct addr tunnel_dst;$/;"	m	struct:router_entry	typeref:struct:router_entry::addr
tunnel_src	router.h	/^	struct addr tunnel_src;$/;"	m	struct:router_entry	typeref:struct:router_entry::addr
tunnelcompare	router.c	/^int tunnelcompare(struct router_entry *a, struct router_entry *b)$/;"	f
tuple	honeyd.h	/^struct tuple$/;"	s
tuple_find	honeyd.c	/^tuple_find(struct tree *root, struct tuple *key)$/;"	f
tuple_iterate	honeyd.c	/^int tuple_iterate(struct conlru *head, int (*f)(struct tuple *, void *),$/;"	f
tv	keycount.h	/^	struct timeval tv;$/;"	m	struct:timeentry	typeref:struct:timeentry::timeval
tv	template.h	/^	struct timeval tv; \/* drifted time *\/$/;"	m	struct:__anon9	typeref:struct:__anon9::timeval
tv_busy	router.h	/^	struct timeval tv_busy;	\/* time that we are busy sending *\/$/;"	m	struct:link_entry	typeref:struct:link_entry::timeval
tv_end	stats.h	/^	struct timeval tv_end;$/;"	m	struct:measurement	typeref:struct:measurement::timeval
tv_end	tagging.h	/^	struct timeval tv_end; \/* optional *\/$/;"	m	struct:record	typeref:struct:record::timeval
tv_hours	histogram.h	/^	struct timeval tv_hours;$/;"	m	struct:count	typeref:struct:count::timeval
tv_last	honeydstats.h	/^	struct timeval tv_last;$/;"	m	struct:honeyuser	typeref:struct:honeyuser::timeval
tv_minutes	histogram.h	/^	struct timeval tv_minutes;$/;"	m	struct:count	typeref:struct:count::timeval
tv_next	keycount.h	/^	struct timeval tv_next;$/;"	m	struct:timeseries	typeref:struct:timeseries::timeval
tv_now	histogram.c	/^static struct timeval *tv_now;	\/* used for unittesting *\/$/;"	v	typeref:struct:timeval	file:
tv_periodic	histogram.c	/^static struct timeval tv_periodic;$/;"	v	typeref:struct:timeval	file:
tv_periodic	personality.c	/^static struct timeval tv_periodic;$/;"	v	typeref:struct:timeval	file:
tv_real	template.h	/^	struct timeval tv_real; \/* real wall time *\/$/;"	m	struct:__anon9	typeref:struct:__anon9::timeval
tv_restart	subsystem.h	/^	struct timeval tv_restart; \/* time last started *\/$/;"	m	struct:subsystem	typeref:struct:subsystem::timeval
tv_seconds	histogram.h	/^	struct timeval tv_seconds;$/;"	m	struct:count	typeref:struct:count::timeval
tv_start	keycount.h	/^	struct timeval tv_start;$/;"	m	struct:timeseries	typeref:struct:timeseries::timeval
tv_start	stats.c	/^	struct timeval tv_start;$/;"	m	struct:statscontrol	typeref:struct:statscontrol::timeval	file:
tv_start	stats.h	/^	struct timeval tv_start;$/;"	m	struct:measurement	typeref:struct:measurement::timeval
tv_start	tagging.h	/^	struct timeval tv_start; \/* optional *\/$/;"	m	struct:record	typeref:struct:record::timeval
tv_started	rrdtool.h	/^	struct timeval tv_started;$/;"	m	struct:rrdtool_drv	typeref:struct:rrdtool_drv::timeval
tv_update	keycount.h	/^	struct timeval tv_update;$/;"	m	struct:timeseries	typeref:struct:timeseries::timeval
tv_when	honeydstats.h	/^	struct timeval tv_when;	\/* first time we heard from this user *\/$/;"	m	struct:honeyuser	typeref:struct:honeyuser::timeval
type	honeyd.h	/^	int type; \/* Either SOCK_STREAM or SOCK_DGRAM *\/$/;"	m	struct:tuple
type	honeyd_overload.c	/^	int type;$/;"	m	struct:fd	file:
type	router.h	/^	enum route_type type;$/;"	m	struct:router_entry	typeref:enum:router_entry::route_type
type	subsystem.h	/^	int type;$/;"	m	struct:subsystem_command
u_int	acconfig.h	14;"	d
u_int16_t	acconfig.h	23;"	d
u_int32_t	acconfig.h	20;"	d
u_int64_t	acconfig.h	17;"	d
u_int8_t	acconfig.h	26;"	d
uck	personality.h	/^	enum rval uck;$/;"	m	struct:persudp	typeref:enum:persudp::rval
udp	template.h	/^	struct action udp;$/;"	m	struct:__anon9	typeref:struct:__anon9::action
udp_add_readbuf	udp.c	/^udp_add_readbuf(struct udp_con *con, u_char *dat, u_int datlen)$/;"	f
udp_con	honeyd.h	/^struct udp_con$/;"	s
udp_free	honeyd.c	/^void udp_free(struct udp_con *con)$/;"	f
udp_new	honeyd.c	/^udp_new(struct ip_hdr *ip, struct ip6_hdr *ip6, struct udp_hdr *udp, int local,$/;"	f
udp_recv_cb	honeyd.c	/^void udp_recv_cb(struct template *tmpl, u_char *pkt, u_short pktlen)$/;"	f
udp_recv_cb	hsniff.c	/^void udp_recv_cb(u_char *pkt, u_short pktlen)$/;"	f
udp_recv_cb46	honeyd.c	/^void udp_recv_cb46(struct template *tmpl, u_char *pkt, u_short pktlen,$/;"	f
udp_send	honeyd.c	/^int udp_send(struct udp_con *con, u_char *payload, u_int len)$/;"	f
udpcons	honeyd.c	/^struct tree udpcons;$/;"	v	typeref:struct:tree
udplru	honeyd.c	/^struct conlru udplru;$/;"	v	typeref:struct:conlru
udptest	personality.h	/^	struct persudp udptest;$/;"	m	struct:personality	typeref:struct:personality::persudp
ui_buffer_prompt	ui.c	/^ui_buffer_prompt(struct uiclient *client)$/;"	f
ui_command_help	ui.c	/^ui_command_help(struct evbuffer *buf, char *line)$/;"	f
ui_command_python	ui.c	/^ui_command_python(struct evbuffer *buf, char *line)$/;"	f
ui_dead	ui.c	/^ui_dead(struct uiclient *client)$/;"	f
ui_file	ui.c	/^char *ui_file = UI_FIFO;$/;"	v
ui_greeting	ui.c	/^ui_greeting(struct uiclient *client)$/;"	f
ui_handle_command	ui.c	/^ui_handle_command(struct evbuffer *buf, char *original)$/;"	f
ui_handler	ui.c	/^ui_handler(int fd, short what, void *arg)$/;"	f
ui_init	ui.c	/^ui_init(void)$/;"	f
ui_new	ui.c	/^ui_new(int fd, short what, void *arg)$/;"	f
ui_write_prompt	ui.c	/^ui_write_prompt(struct uiclient *client)$/;"	f
ui_writer	ui.c	/^ui_writer(int fd, short what, void *arg)$/;"	f
uiclient	ui.h	/^struct uiclient {$/;"	s
uid	template.h	/^	uid_t uid;$/;"	m	struct:__anon9
unfragmentable_header	ip6frag.c	/^uint8_t unfragmentable_header[] = { IPPROTO_HOPOPTS, IPPROTO_ROUTING };$/;"	v
unittest	honeyd.c	/^void unittest(void)$/;"	f
unittest	honeydstats_main.c	/^void unittest(void)$/;"	f
unittests	honeyd.c	/^} unittests[] =$/;"	v	typeref:struct:_unittest
unittests	honeydstats_main.c	/^} unittests[] =$/;"	v	typeref:struct:_unittest
unput	lex.c	207;"	d	file:
unused	honeyd.h	/^	uint8_t sentfin :1, finacked :1, sawwscale :1, sawtimestamp :1, unused :4;$/;"	m	struct:tcp_con
unused	honeyd.h	/^	unused :5;$/;"	m	struct:command
unused	personality.h	/^	        unused:7;$/;"	m	struct:personality
update_cb	update.c	/^update_cb(int fd, short what, void *arg)$/;"	f
update_check	update.c	/^update_check(void)$/;"	f
update_connect_cb	update.c	/^update_connect_cb(int fd, short what, void *arg)$/;"	f
update_connect_ev	update.c	/^static struct event update_connect_ev;$/;"	v	typeref:struct:event	file:
update_errorcb	update.c	/^update_errorcb(struct bufferevent *bev, short what, void *parameter)$/;"	f	file:
update_ev	update.c	/^static struct event update_ev;$/;"	v	typeref:struct:event	file:
update_ev_initialized	update.c	/^static int update_ev_initialized;$/;"	v	file:
update_make_request	update.c	/^update_make_request(struct bufferevent *bev)$/;"	f
update_node	keycount.h	/^	SPLAY_ENTRY(timeseries) update_node;$/;"	m	struct:timeseries
update_parse_information	update.c	/^update_parse_information(char *data, size_t length)$/;"	f	file:
update_readcb	update.c	/^update_readcb(struct bufferevent *bev, void *parameter)$/;"	f	file:
update_writecb	update.c	/^update_writecb(struct bufferevent *bev, void *parameter)$/;"	f	file:
usage	honeyd.c	/^void usage(void)$/;"	f
usage	honeydctl.c	/^usage()$/;"	f
usage	honeydstats_main.c	/^void usage(void)$/;"	f
usage	hsniff.c	/^void usage(void)$/;"	f
user_compare	honeydstats.c	/^static int user_compare(struct honeyuser *a, struct honeyuser *b)$/;"	f	file:
user_data	hooks.c	/^	void                           *user_data;$/;"	m	struct:honeyd_packet_hook	file:
user_dst	stats.c	/^	struct addr *user_dst;$/;"	m	struct:statscontrol	typeref:struct:statscontrol::addr	file:
user_key	stats.c	/^	char *user_key;$/;"	m	struct:statscontrol	file:
user_name	stats.c	/^	char *user_name;$/;"	m	struct:statscontrol	file:
user_new	honeydstats.c	/^void user_new(const char *name, const char *password)$/;"	f
user_port	stats.c	/^	u_short user_port;$/;"	m	struct:statscontrol	file:
user_read_config	honeydstats.c	/^int user_read_config(const char *filename)$/;"	f
users	honeydstats.c	/^struct usertree users;$/;"	v	typeref:struct:usertree
val	personality.h	/^	uint32_t val;		\/* Used for constant ISNs *\/$/;"	m	struct:personality
vallen	pydataprocessing.h	/^	size_t vallen;$/;"	m	struct:SingleValue
valset	personality.h	/^	uint8_t valset:1,$/;"	m	struct:personality
value	analyze.h	/^	uint32_t value;$/;"	m	struct:auxkey
value	pydataprocessing.h	/^	u_char *value;$/;"	m	struct:SingleValue
value	util.h	/^	char *value;$/;"	m	struct:keyvalue
values	pydataprocessing.h	/^	TAILQ_HEAD(singlevalq, SingleValue) values;$/;"	m	struct:MergedKeyValue
vendor	ethernet.c	/^	char *vendor;$/;"	m	struct:ethernetcode	file:
version	plugins.h	/^	const char *version;$/;"	m	struct:honeyd_plugin
wantwrite	pyextend.c	/^	int wantwrite;$/;"	m	struct:pystate	file:
warn	err.c	/^warn(const char *fmt, ...)$/;"	f
warnx	err.c	/^warnx(const char *fmt, ...)$/;"	f
window	honeyd.h	/^	u_short window;$/;"	m	struct:tcp_con
window	personality.h	/^	int window;$/;"	m	struct:personate
xid	dhcpclient.h	/^	uint32_t        xid;$/;"	m	struct:dhcpclient_req
xp_fingerprint	personality.h	/^struct xp_fingerprint {$/;"	s
xp_fp_flags	personality.h	/^struct xp_fp_flags {$/;"	s
xp_fp_ttlvals	personality.h	/^struct xp_fp_ttlvals {$/;"	s
xp_fprint	personality.h	/^	struct xp_fingerprint *xp_fprint;$/;"	m	struct:personality	typeref:struct:personality::xp_fingerprint
xp_fprint	xprobe_assoc.h	/^	struct xp_fingerprint   *xp_fprint;$/;"	m	struct:assoc_item	typeref:struct:assoc_item::xp_fingerprint
xp_fprint_compare	personality.h	/^xp_fprint_compare(struct xp_fingerprint *a, struct xp_fingerprint *b)$/;"	f
xprobe	honeyd.h	/^	char *xprobe;$/;"	m	struct:config
xprobe_personality_init	personality.c	/^xprobe_personality_init(void)$/;"	f
xprobe_personality_parse	personality.c	/^xprobe_personality_parse(FILE *fp)$/;"	f
yy_accept	lex.c	/^static yyconst flex_int16_t yy_accept[372] =$/;"	v	file:
yy_at_bol	lex.c	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	file:
yy_base	lex.c	/^static yyconst flex_int16_t yy_base[385] =$/;"	v	file:
yy_bs_column	lex.c	/^    int yy_bs_column; \/**< The column count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_bs_lineno	lex.c	/^    int yy_bs_lineno; \/**< The line count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_pos	lex.c	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_size	lex.c	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	file:
yy_buffer_stack	lex.c	/^static YY_BUFFER_STATE * yy_buffer_stack = 0; \/**< Stack as an array. *\/$/;"	v	file:
yy_buffer_stack_max	lex.c	/^static size_t yy_buffer_stack_max = 0; \/**< capacity of stack. *\/$/;"	v	file:
yy_buffer_stack_top	lex.c	/^static size_t yy_buffer_stack_top = 0; \/**< index of top of stack. *\/$/;"	v	file:
yy_buffer_state	lex.c	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_status	lex.c	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	file:
yy_c_buf_p	lex.c	/^static char *yy_c_buf_p = (char *) 0;$/;"	v	file:
yy_ch_buf	lex.c	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_chk	lex.c	/^static yyconst flex_int16_t yy_chk[531] =$/;"	v	file:
yy_create_buffer	lex.c	8;"	d	file:
yy_def	lex.c	/^static yyconst flex_int16_t yy_def[385] =$/;"	v	file:
yy_delete_buffer	lex.c	9;"	d	file:
yy_delete_buffer	parse.c	127;"	d	file:
yy_did_buffer_switch_on_eof	lex.c	/^static int yy_did_buffer_switch_on_eof;$/;"	v	file:
yy_ec	lex.c	/^static yyconst flex_int32_t yy_ec[256] =$/;"	v	file:
yy_fatal_error	lex.c	/^static void yy_fatal_error (yyconst char* msg )$/;"	f	file:
yy_fill_buffer	lex.c	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_flex_debug	lex.c	10;"	d	file:
yy_flex_strlen	lex.c	/^static int yy_flex_strlen (yyconst char * s )$/;"	f	file:
yy_flex_strncpy	lex.c	/^static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )$/;"	f	file:
yy_flush_buffer	lex.c	12;"	d	file:
yy_get_next_buffer	lex.c	/^static int yy_get_next_buffer (void)$/;"	f	file:
yy_get_previous_state	lex.c	/^    static yy_state_type yy_get_previous_state (void)$/;"	f	file:
yy_hold_char	lex.c	/^static char yy_hold_char;$/;"	v	file:
yy_init	lex.c	/^static int yy_init = 0;		\/* whether we need to initialize *\/$/;"	v	file:
yy_init_buffer	lex.c	11;"	d	file:
yy_init_globals	lex.c	/^static int yy_init_globals (void)$/;"	f	file:
yy_input_file	lex.c	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	file:
yy_is_interactive	lex.c	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	file:
yy_is_our_buffer	lex.c	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_last_accepting_cpos	lex.c	/^static char *yy_last_accepting_cpos;$/;"	v	file:
yy_last_accepting_state	lex.c	/^static yy_state_type yy_last_accepting_state;$/;"	v	file:
yy_load_buffer_state	lex.c	13;"	d	file:
yy_meta	lex.c	/^static yyconst flex_int32_t yy_meta[45] =$/;"	v	file:
yy_n_chars	lex.c	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	file:
yy_n_chars	lex.c	/^static int yy_n_chars;		\/* number of characters read into yy_ch_buf *\/$/;"	v	file:
yy_new_buffer	lex.c	336;"	d	file:
yy_nxt	lex.c	/^	flex_int32_t yy_nxt;$/;"	m	struct:yy_trans_info	file:
yy_nxt	lex.c	/^static yyconst flex_int16_t yy_nxt[531] =$/;"	v	file:
yy_reduce_print	parse.c	/^yy_reduce_print (YYSTYPE *yyvsp, int yyrule)$/;"	f	file:
yy_scan_string	parse.c	126;"	d	file:
yy_set_bol	lex.c	348;"	d	file:
yy_set_interactive	lex.c	338;"	d	file:
yy_size_t	lex.c	/^typedef size_t yy_size_t;$/;"	t	file:
yy_stack_print	parse.c	/^yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)$/;"	f	file:
yy_start	lex.c	/^static int yy_start = 0;	\/* start state number *\/$/;"	v	file:
yy_state_type	lex.c	/^typedef int yy_state_type;$/;"	t	file:
yy_switch_to_buffer	lex.c	14;"	d	file:
yy_symbol_print	parse.c	/^yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_symbol_value_print	parse.c	/^yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_trans_info	lex.c	/^struct yy_trans_info$/;"	s	file:
yy_try_NUL_trans	lex.c	/^    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )$/;"	f	file:
yy_verify	lex.c	/^	flex_int32_t yy_verify;$/;"	m	struct:yy_trans_info	file:
yyalloc	lex.c	23;"	d	file:
yyalloc	parse.c	/^union yyalloc$/;"	u	file:
yychar	parse.c	/^int yychar;$/;"	v
yycheck	parse.c	/^static const yytype_int16 yycheck[] =$/;"	v	file:
yyclearin	parse.c	1021;"	d	file:
yyconst	lex.c	125;"	d	file:
yyconst	lex.c	127;"	d	file:
yydebug	parse.c	/^int yydebug;$/;"	v
yydefact	parse.c	/^static const yytype_uint8 yydefact[] =$/;"	v	file:
yydefgoto	parse.c	/^static const yytype_int16 yydefgoto[] =$/;"	v	file:
yydestruct	parse.c	/^yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)$/;"	f	file:
yyerrok	parse.c	1020;"	d	file:
yyerror	lex.c	781;"	d	file:
yyerror	parse.c	/^yyerror(char *fmt, ...)$/;"	f
yyerror	parse.c	128;"	d	file:
yyfree	lex.c	25;"	d	file:
yyin	lex.c	15;"	d	file:
yyin	parse.c	131;"	d	file:
yyinput	lex.c	/^    static int yyinput (void)$/;"	f	file:
yyleng	lex.c	16;"	d	file:
yyless	lex.c	194;"	d	file:
yyless	lex.c	2383;"	d	file:
yyless	lex.c	2384;"	d	file:
yylex	lex.c	17;"	d	file:
yylex	parse.c	124;"	d	file:
yylineno	lex.c	18;"	d	file:
yylval	parse.c	/^YYSTYPE yylval;$/;"	v
yymore	lex.c	711;"	d	file:
yynerrs	parse.c	/^int yynerrs;$/;"	v
yyout	lex.c	19;"	d	file:
yypact	parse.c	/^static const yytype_int16 yypact[] =$/;"	v	file:
yypact_value_is_default	parse.c	955;"	d	file:
yyparse	parse.c	/^yyparse (void *YYPARSE_PARAM)$/;"	f
yyparse	parse.c	125;"	d	file:
yypgoto	parse.c	/^static const yytype_int16 yypgoto[] =$/;"	v	file:
yyprhs	parse.c	/^static const yytype_uint16 yyprhs[] =$/;"	v	file:
yyprintf	parse.c	/^yyprintf(char *fmt, ...)$/;"	f
yyprintf	parse.c	130;"	d	file:
yyr1	parse.c	/^static const yytype_uint8 yyr1[] =$/;"	v	file:
yyr2	parse.c	/^static const yytype_uint8 yyr2[] =$/;"	v	file:
yyrealloc	lex.c	24;"	d	file:
yyrestart	lex.c	20;"	d	file:
yyrhs	parse.c	/^static const yytype_int8 yyrhs[] =$/;"	v	file:
yyrline	parse.c	/^static const yytype_uint16 yyrline[] =$/;"	v	file:
yyss_alloc	parse.c	/^  yytype_int16 yyss_alloc;$/;"	m	union:yyalloc	file:
yystos	parse.c	/^static const yytype_uint8 yystos[] =$/;"	v	file:
yystpcpy	parse.c	/^yystpcpy (char *yydest, const char *yysrc)$/;"	f	file:
yystpcpy	parse.c	1317;"	d	file:
yystrlen	parse.c	/^yystrlen (const char *yystr)$/;"	f	file:
yystrlen	parse.c	1294;"	d	file:
yystype	parse.c	383;"	d	file:
yystype	parse.h	247;"	d
yysyntax_error	parse.c	/^yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,$/;"	f	file:
yytable	parse.c	/^static const yytype_uint8 yytable[] =$/;"	v	file:
yytable_value_is_error	parse.c	958;"	d	file:
yyterminate	lex.c	933;"	d	file:
yytext	lex.c	21;"	d	file:
yytext_ptr	lex.c	373;"	d	file:
yytname	parse.c	/^static const char *const yytname[] =$/;"	v	file:
yytnamerr	parse.c	/^yytnamerr (char *yyres, const char *yystr)$/;"	f	file:
yytokentype	parse.c	/^   enum yytokentype {$/;"	g	file:
yytokentype	parse.h	/^   enum yytokentype {$/;"	g
yytoknum	parse.c	/^static const yytype_uint16 yytoknum[] =$/;"	v	file:
yytranslate	parse.c	/^static const yytype_uint8 yytranslate[] =$/;"	v	file:
yytype_int16	parse.c	/^typedef YYTYPE_INT16 yytype_int16;$/;"	t	file:
yytype_int16	parse.c	/^typedef short int yytype_int16;$/;"	t	file:
yytype_int8	parse.c	/^typedef YYTYPE_INT8 yytype_int8;$/;"	t	file:
yytype_int8	parse.c	/^typedef short int yytype_int8;$/;"	t	file:
yytype_int8	parse.c	/^typedef signed char yytype_int8;$/;"	t	file:
yytype_uint16	parse.c	/^typedef YYTYPE_UINT16 yytype_uint16;$/;"	t	file:
yytype_uint16	parse.c	/^typedef unsigned short int yytype_uint16;$/;"	t	file:
yytype_uint8	parse.c	/^typedef YYTYPE_UINT8 yytype_uint8;$/;"	t	file:
yytype_uint8	parse.c	/^typedef unsigned char yytype_uint8;$/;"	t	file:
yyunput	lex.c	/^    static void yyunput (int c, register char * yy_bp )$/;"	f	file:
yyvs_alloc	parse.c	/^  YYSTYPE yyvs_alloc;$/;"	m	union:yyalloc	file:
yywarn	parse.c	/^yywarn(char *fmt, ...)$/;"	f
yywarn	parse.c	129;"	d	file:
yywrap	lex.c	22;"	d	file:
